<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">
  <title>FoE Engine: Game Editor tutorial</title>
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/blog-home.css" rel="stylesheet">
  
  <style>
    .folder-list-table {
      width: 100%;
    }
    .folder-list-table tr {
      border: 1px lightgray solid;
    }
    .folder-list-table td {
      padding: 2px;
    }
    .folder-list-table td:first-of-type {
      font-family: monospace;
      padding-right: 10px;
    }  
  
    .end-chapter { height: 50px; }
    .mono-span { font-family: monospace; display: inline-block; background-color: lightgray; padding: 1px; }
    .code {
      padding: 15px 10px;
      margin: 0 -5px 20px;
      background-color: lightgray;
    }
    .code-header {
      background-color: lightgray;
      border-bottom: 1px solid black;
      padding: 2px 10px;
      margin: 0 -5px;
      font-family: monospace;
      color: gray;
    }
    video {
      margin: 10px 0 15px;
    }
    
    .card-text.card-hint, .card-text.warning {
      position: relative;
      display: block;
      border-radius: 15px;
      background-color: rgba(255, 150, 0, 0.5);
      padding: 10px;
      margin: 10px;
      padding-left: 60px;
      margin-bottom: 20px;
    }

    .card-text.card-hint::before {
      position: absolute;
      left: 10px;
      top: calc(50% - 20px);
      content: "?";
      display: block;
      background-color: blue;
      color: white;
      width: 40px;
      height: 40px;
      text-align: center;
      border-radius: 40px;
      font-weight: bold;
      padding-top: 2px;
      font-size: 22px;
      border: 2px solid white;
    }
    
    .card-text.warning::before {
      position: absolute;
      left: 10px;
      top: calc(50% - 20px);
      content: "!";
      display: block;
      background-color: yellow;
      color: black;
      width: 40px;
      height: 40px;
      text-align: center;
      border-radius: 40px;
      font-weight: bold;
      padding-top: 2px;
      font-size: 22px;
      border: 2px solid black;
    }

  </style>
</head>

<body style="padding-top:0">
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container">
      <a class="navbar-brand" href="#"><h3>Fallout Equestria Engine</h3>Game Editor tutorial</a>
    </div>
  </nav>

  <!-- Page Content -->
  <div class="container">
    <div class="row">
      <!-- Blog Entries Column -->
      <div class="col-md-8" id="getting-started">
        <h1 class="my-4">
          Getting started
        </h1>

        <!-- Blog Post -->
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title">What do you need to make games using the FoE engine ?</h4>
            <p class="card-text">
You will need:

<ul>
  <li>Tiled (<a href="http://mapeditor.org">http://mapeditor.org</a>), used to create the tilemaps for the game levels,</li>
  <li>Fallout Equestria Development Release, a build of the engine that includes a game editor,</li>
  <li>Knowledge of modular JavaScript.</li>
</ul>
            </p>
          </div>
        </div>

        <h2 class="my-4" id="c1">1. Level design</h2>

        <div class="card mb-4">
          <div class="card-body">
            <div class="chapter">
            
              <p class="card-text">
                Designing level starts with Tiled, building tilemaps, and ends in the Game editor, adding interactive objects and NPCs. In this chapter, we will go over how to build tilemaps suitable for our game engine.<br/>
                Download and install <a href="https://thorbjorn.itch.io/tiled">Tiled</a>, if you haven't already done so, and let's get started:
              </p>
            
              <h4 class="card-title" id="c2-1">1.1 Creating a new tilemap</h4>

              <p class="card-text">
                Go to <span class="mono-span">File -> New -> New map</span> to open the new tilemap dialog:
              </p>
              
              <p class="card-text">
                <img src="pictures/tiled-new-map.png" />
              </p>
              
              <p class="card-text">
                The tile size must be 72x36, orientation must be isometric, and tile order should be left-down.<br/>
                Click the "Save as", and save your tilemap in <span class="mono-span">assets/tilemaps</span> as <span class="mono-span">stable-cavern.json</span>.
              </p>
              
              <p class="card-text">
                We will now import a tileset to paint our tilemap. Click the "Open" button:
              </p>

              <p class="card-text">
                <img src="pictures/tiled-open-tileset.png" />
              </p>
              
              <p class="card-text">
                Go to the <span class="mono-span">assets/tilesets</span> folder and open the three following files:
                
                <ul>
                  <li><span class="mono-span">tileset-1.json</span>, a tileset for ground and roof tiles.</li>
                  <li><span class="mono-span">walls-1.json</span>, a tileset for walls.</li>
                  <li><span class="mono-span">zones.json</span>, a tileset of semi-transparent tiles for tile zones.</li>
                </ul>
              </p>
              
              <p class="card-text">
                One last thing before you can start painting your tilemap: rename the tile layer to <i>ground</i>.
              </p>
              
              <p class="card-text">
                <img src="pictures/tiled-ground-layer.png" />
              </p>
              
              <p class="card-text">
                Everything's ready to go, you can start painting the ground layer of your tilemap. The result might end up a bit like this:
              </p>
              
              <p class="card-text">
                <img class="card-img-top" src="pictures/tiled-ground-painted.png" />
              </p>

              <p class="card-text warning">
                One important thing to know is that the ground and roof layers from your tilemaps get pre-rendered and cached in the <span class="mono-span">.prerender</span> folder. If you want to update those layers, don't forget to remove that folder, which will force the game engine to render your tilemap again, with your changes included.
              </p>

              <div class="end-chapter"></div>

              <h4 class="card-title" id="c1-2">1.2 Walls</h4>
              
              <p class="card-text">
                Now that we know how to paint the ground, let's move on to the walls. We will need to create a new layer of tiles, called <i>walls</i>:
              </p>
              
              <p class="card-text">
                <img src="pictures/tiled-wall-layer.png" />
              </p>
              
              <p class="card-text">
                You can pick walls from the <i>walls-1</i> tileset we opened earlier, and start painting your walls now.
              </p>
              
              <p class="card-text">
                It is important to note that walls will be used by the game engine to figure out which tiles the characters can move on, and which should be blocked.
              </p>
              
              <p class="card-text">
                If you wish to put on wall-like structures, but which do not block the path (doorways for instance), you may create another layer, called <i>misc</i>. Tiles in the <i>misc</i> layer are rendered in the same process as walls. The <i>walls-1</i> tileset includes such doorways that should be inserted in the <i>misc</i> layer. Do not worry about the render order as it is shown by Tiled: for the game engine, tiles from the <i>walls</i> and <i>misc</i> layers act as if they were from the same layer.
              </p>

              <div class="end-chapter"></div>

              <h4 class="card-title" id="c1-3">1.3 Roofs</h4>
              
              <p class="card-text">
                We'll now put roofs over those walls. Unlike the ground and the walls, roofs are stored in multiple layers: that is because when the player character is under a roof tile, the whole layer disappears, while the other roof layers remain visible.
              </p>
              
              <p class="card-text">
                The first step is to create a layer group named <i>roofs</i>. In this folder, you can then add any number of tile layer, named however you want:
              </p>
              
              <p class="card-text">
                <img src="pictures/tiled-roof-layer.png" />
              </p>
              
              <p class="card-text">
                Roof layers also have another particularity: they are rendered at a diffrent offset than other layers. For each of your roof layer, you must set the property "Vertical offset" to -72:
              </p>
              
              <p class="card-text">
                <img src="pictures/tiled-roof-properties.png" />
              </p>
              
              <p class="card-text">
                You may now start painting your roof layers. <i>tileset-1</i> includes some roof tiles you can use at your leisure.
              </p>

              <div class="end-chapter"></div>

              <h4 class="card-title" id="c1-4">1.4 Zones</h4>
              
              <p class="card-text">
                The last thing you will have to do in Tiled will be drawing tile zone. Tile zones can serve the following purposes:
                
                <ul>
                  <li>Entry zones can be used to insert a party of characters. It is mostly used when the map is entered by the player, to insert him along with his party.</li>
                  <li>Exit zones can be used by the player character to exit a map. These zones can redirect either to another map or to the worldmap.</li>
                  <li>Other zones can be used by scripts, to get a list of the objects in a zone (characters included), or to monitor what enters or exits the zone.</li>
                </ul>
              </p>
              
              <p class="card-text">
                Note that exit zones are the only ones visible to the player. The tiles used when rendering the exit zones depend on whether the exit zone will send the player to another tilemap, or to the worldmap: it does not matter which kind of tile you use in Tiled to define your zone.
              </p>
              
              <p class="card-text">
                Let us create an exit and an entry zone for our tilemap. Like roofs, zones are grouped in a layer group: create the <i>zones</i> layer group, and add two new tile layers, called <i>exit-zone</i> and <i>demo-begin</i>:
              </p>
              
              <p class="card-text">
                <img src="pictures/tiled-zone-layer.png" />
              </p>
              
              <p class="card-text">
                We will start by creating the entry zone. We will have to set some custom property on our zone's tile layer, before drawing the zone, as shown in the following video:
              </p>
              
              <video class="card-img-top" src="videos/24-create-entry-zone.webm" autoplay loop controls muted>
              </video>
              
              <p class="card-text">
                We first created the <span class="mono-span">type</span> property, which will indicate the game engine our zone type. Authorized values are <i>entry</i>, <i>exit</i>, or an empty string. 
              </p>
              
              <p class="card-text">
                As we are creating an entry-zone, we can also set the <span class="mono-span">default</span> property: when no entry zone name is explicitely found, or none match the zone name provided, characters will be inserted in this zone instead. As such, it is also the zone in which the player arrives when coming from the worldmap.
              </p>
              
              <p class="card-text">
                Creating our exit zone is very similar, but we may provide other custom properties:
                <ul>
                  <li><span class="mono-span">target</span> can be set to the name of the tilemap you wish to redirect to.</li>
                  <li><span class="mono-span">toZone</span> should be set to the name of the entry zone you wish the player to be redirected to.</li>
                </ul>
              </p>

              <p class="card-text card-hint">
                If both <span class="mono-span">target</span> and <span class="mono-span">toZone</span> are left empty, the exit zone will send the player to the worldmap.<br/>
                If only <span class="mono-span">target</span> is empty, the exit zone will look for an entry zone corresponding to <span class="mono-span">toZone</span> in the current tilemap.
              </p>

              <div class="end-chapter"></div>
              
              <h4 class="card-title" id="c1-5">1.5 Light zones</h4>
              
              <p class="card-text">
                There is also one last special type of zone: light zones are used to draw light effects on the tilemap, while allowing bonuses for perception related tests on objects affected by a light zone. Light zones can also be turned on and off by scripts.
              </p>
              
              <p class="card-text">
                Light zones are located in the <span class="mono-span">lights</span> layer group. Create a new tile layer as such:
              </p>
              
              <p class="card-text">
                <img src="pictures/tiled-light-layer.png" />
              </p>
              
              <p class="card-text">
                Open the tileset located at <span class="mono-span">assets/tilesets/lights.json</span>, and you can now start drawing light zones:
              </p>
              
              <video class="card-img-top" src="videos/25-draw-light-zone.webm" autoplay loop controls muted>
              </video>

              <div class="end-chapter"></div>
            </div>
          </div>
        </div>
        
<h2 class="my-4" id="c2">
          2. Scripting introduction
        </h2>
        
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title" id="c2-1">2.1 Folder structure</h4>
            <p class="card-text">
              Before writing any scripts, let's have a look at the folder structure you'll be working with. There are quite a lot of places for various types of files, so just remember this is here and use it as a reference.
              
              <table class="folder-list-table">
                <tr>
                  <th>Path</th>
                  <th>Role</th>
                </tr>
                <tr>
                  <td>assets/tilemaps</td>
                  <td> the target folder for your Tiled tilemaps</td>
                </tr>
                <tr>
                  <td>assets/tilesets</td>
                  <td> the target folder for your Tiled tilesets</td>
                </tr>
                <tr>
                  <td>assets/locales</td>
                  <td> translations files are located there</td>
                </tr>
                <tr>
                  <td>assets/videos</td>
                  <td> root folder for video files</td>
                </tr>
                <tr>
                  <td>assets/audio</td>
                  <td> root folder for audio files</td>
                </tr>
                <tr>
                  <td>assets/sprites</td>
                  <td> root folder for spritesheets</td>
                </tr>
                <tr>
                  <td>scripts/cmap/traits</td>
                  <td> CMAP traits plugins folder</td>
                </tr>
                <tr>
                  <td>scripts/cmap/races</td>
                  <td> CMAP races plugins folder</td>
                </tr>
                <tr>
                  <td>scripts/cmap/perks</td>
                  <td> CMAP perks plugins folder</td>
                </tr>
                <tr>
                  <td>scripts/quests</td>
                  <td> Quest folder</td>
                </tr>
                <tr>
                  <td>scripts/dialogs</td>
                  <td> Dialog folder</td>
                </tr>
                <tr>
                  <td>scripts/levels</td>
                  <td> Level-context scripts (each level can implement one)</td>
                </tr>
                <tr>
                  <td>scripts/pnjs</td>
                  <td> Characters scripts</td>
                </tr>
                <tr>
                  <td>scripts/items</td>
                  <td> InventoryItems scripts</td>
                </tr>
                <tr>
                  <td>scripts/behaviour</td>
                  <td> All other DynamicObjects scripts</td>
                </tr>
              </table>
            </p>
            <p class="card-text">
              Let's also have a look at a series of useful files:
              <table class="folder-list-table">
                <tr>
                  <th>Path</th>
                  <th>Role</th>
                </tr>
                <tr>
                  <td>assets/audio.json</td>
                  <td> maps audio files to nicknames</td>
                </tr>
                <tr>
                  <td>assets/musics.json</td>
                  <td> set of playlists prepared for certain contexts (specific level, worldmap, main menu)</td>
                </tr>
                <tr>
                  <td>assets/sprites.json</td>
                  <td> library of animation and animations groups (should be edited using the Game Editor)</td>
                </tr>
                <tr>
                  <td>assets/objects.json</td>
                  <td> library of available InventoryItems' item types.</td>
                </tr>
                <tr>
                  <td>assets/worldmap.png</td>
                  <td> Worldmap source</td>
                </tr>
                <tr>
                  <td>scripts/main.mjs</td>
                  <td> Game-context script</td>
                </tr>
                <tr>
                  <td>scripts/initialize.mjs</td>
                  <td> A simple script that initializes the Game context once a new game starts.</td>
                </tr>
              </table>
            </p>
            <div class="end-chapter"></div>
            <h4 class="card-title" id="c2-2">2.2 Initializing a new game</h4>
            <p class="card-text">
The first thing you want to do is to take control of the entry point of the game. You want the player to start at a specific place in the WorldMap, and possibly to start directly inside a Level.
            </p>

            <p class="card-text">
To achieve such results, we will use the <span class="mono-span">scripts/initialize.mjs</span> file. It gets triggered once the players finishes character creation, allowing you to insert any sort of transition and set up the beginning of the game.
            </p>

            <p class="card-text">
The <span class="mono-span">initialize.mjs</span> is a very simple script, and must only export a single <span class="mono-span">initialize</span> function, as such:
            </p>
            
            <div class="code-header">scripts/initialize.mjs</div>
            <pre class="code javascript"><code>export function initialize() {
  game.onCityEntered("stable-cavern", "demo-begin");
  game.worldmap.setPosition(150, 250);
  game.transitionRequired("intro.mp4", 1);
}</code></pre>

            <p class="card-text">
This scripts does three things:
<ul>
  <li>The first line uses <span class="mono-span">game.onCityEntered</span> to load the <span class="mono-span">stable-cavern</span> level (corresponding to the tilemap stored in <span class="mono-span">assets/tilemaps/stable-cavern.json</span>). The second parameter <span class="mono-span">demo-begin</span> defines the zone in which to insert the player.</li>
  

  <li>The second lines instantly move the character to a specific position on the worldmap.</li>

  <li>The third lines starts a transition using <span class="mono-span">game.transitionRequired</span>. Transitions can be started at anytime during the game: the first paremeter specifies which video file to play (the path is relative to the <span class="mono-span">assets/videos</span> folder), and the second parameter defines how much game-world seconds should pass during the transition (in this case, only one second will pass in the game world while the player watches the video).</li>
</ul>
            </p>
            
            <p class="card-text card-hint">
              <span class="mono-span">game</span> is a global variable pointing to the main game object. It is available everywhere, and can be used at any time by scripts to move the player to another area, move ahead in time, or start playing a video.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c2-3">2.3 Customizing the Game script</h4>
            <p class="card-text">
The Game script is located at <span class="mono-span">scripts/main.mjs</span>. It is bounded to the Game context, and as such, gets loaded whenever a game starts, and keeps running until the game is exited or over.
            </p>
            
            <p class="card-text">
The following is the basic structure for all the Game, Level and DynamicObject scripts:
            </p>
            
            <div class="code-header">scripts/main.mjs</div>
            <pre class="code javascript"><code>class Game {
   constructor(model) {
   }
   
   initialize() {
   }
}

export function create(model) {
  return Game(model);
}</code></pre>

            <p class="card-text">
              All game-related scripts must export a <span class="mono-span">create</span> function. The create function takes a model parameter, representing the instance of the managed object. The function must return an instance to a JavaScript object.
            </p>
            
            <p class="card-text">
              All game-related scripts may implement an <span class="mono-span">initialize</span> method. While the constructor will be called everytime an object is instantiated, the <span class="mono-span">initialize</span> method will only be called once, after the first instantiation. Since game objects properties are automatically saved by the game engine, it is best to set their initial value here, if needed.
            </p>
            
            <p class="card-text card-hint hint">
              Note that the managed object (<span class="mono-span">model</span>) for the Game script is the main game object itself, meaning that in this context, <span class="mono-span">model</span> is equal to the <span class="mono-span">game</span> global variable.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c2-4">2.4 Scheduling a task</h4>

            <p class="card-text">
              Let us add some action in that Game script: we will use the TaskManager to create a task that gets called every 5 seconds, and have the light zone we created earlier switch on and off:
            </p>
            
            <pre class="code javascript"><code>export class Game {
  initialize() {
    game.tasks.addTask("myTask", 5000, 0);
  }

  myTask() {
    if (game.level) {
      const myLight = level.tilemap.getLightLayer("my-light");

      if (myLight) {
        myLight.visible = !myLight.visible;
        game.appendToConsole(myLight.visible ? "Lights on !" : "Lights off");
      }
    }
  }
}

export function create(model) {
  return new Game(model);
}</code></pre>

            <p class="card-text">
In this snippet, we use the game global object <span class="mono-span">tasks</span> property to access the object's TaskManager, and call <span class="mono-span">addTask</span> to schedule a new task.

<ul>
  <li>The first parameter is the name of the game object script method I want to call in 5 seconds.</li>
  <li>The second parameter is the time delay between each calls: it is in milliseconds, which means that for a 5 seconds delay, I need to pass a value of 5000</li>
  <li>Finally, the third parameter is the amount of times the task should be triggered. A value of zero means the task will run indefinitely, or until it gets exlicitely removed.</li>
</ul>

In the <span class="mono-span">myTask</span> method, we then check that a level is currently running, we get a hold of our <span class="mono-span">my-light</span> light zone, created in <a href="#c1-5">section 1.5</a>, and we toggle the light on and off.</p>

            <p class="card-text card-hint">
              Keep in mind that the TaskManager does not necessarily call a method from the script that calls <span class="mono-span">addTask</span>: it will try to call that method on the script of the object that owns the TaskManager.
            </p>

            <p class="card-text">
              Lastly, we call <span class="mono-span">game.appendToConsole</span> to display a message on the player's HUD console.
            </p>

            <p class="card-text">
              Now, here's the result of our new <span class="mono-span">initialize.mjs</span> and <span class="mono-span">main.mjs</span> scripts:
            </p>
            
            <video class="card-img-top" src="videos/26-flicker-light-zone.webm" autoplay loop controls muted>
            </video>
          </div>
        </div>

        <h2 class="my-4"  id="c3">
          3. Creating an NPC
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <p class="card-text">
              We will now live a wonderful adventure through NPC creation. After going through the steps of this chapter, you will know how to customize interactions, skill usages, combat behaviour, and how to implement your own custom behaviours.
            </p>
            
            <h4 class="card-title" id="c3-1">3.1 Creating a new Character script</h4>
            
            <p class="card-text">
              Before doing anything else, let's first scaffold our first character script:
            </p>
            
            <div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code javacsript"><code>import {CharacterBehaviour} from "./character.mjs";

class Npc extends CharacterBehaviour {
  constructor(model) {
    super(model);
  }
}

export function create(model) {
  return new Npc(model);
}</code></pre>

            <p class="card-text">CharacterBehaviour is a script helper that implements default behaviour for various interactions, as well as default combat behaviour. We'll mostly be overriding those behaviours to implement our own.</p>

            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-2">3.2 Creating a character sheet</h4>
            
            <p class="card-text">
              As in any RPG, making up character starts with a character sheet. That part of the magic happens in the Game Editor. Start the game editor, go to the NPC tab, and create a new character sheet as such:
            </p>
            
            <video class="card-img-top" src="videos/01-create-character-sheet.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text">
              Before saving the character sheet, it needs to be completed. To complete the statistic sheet, you must:
              <ul>
                <li>You need to set a name, age, gender, race.</li>
                <li>Spend all your SPECIAL points</li>
                <li>Pick two traits</li>
              </ul>
              Optionally, you can also prepare a face for your character, using the face editor as shown below:
            </p>

            <video class="card-img-top" src="videos/02-create-character-face.webm" autoplay loop controls muted></video>
            
            <p class="card-text">
              You can also further customize your NPC's statistics by granting it experience and leveling it up, as following:
            </p>
            
            <video class="card-img-top" src="videos/03-character-set-level.webm" autoplay loop controls muted></video>
            
            <p class="card-text warning">
              Don't forget to <b>click the Confirm button</b> once you're done with your character sheet, otherwise none of your changes will be saved. Your changes will be lost if you swap levels or go back to the main menu without saving.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-3">3.3 Adding an NPC in a level</h4>
            
            <p class="card-text">
              Now that we have a script and a character sheet, we can finally instantiate an NPC in a Level. In the Game Editor, move to the Level tab, and add a character:
            </p>
            
            <video class="card-img-top" src="videos/04-level-add-character.webm" autoplay loop controls muted></video>
            
            <p class="card-text">
              The Level editor uses similar interaction principles as the game itself: you have two mouse cursor mode. The first one picks tiles, the second one picks objects. Right click on the tilemap to swap between modes.
            </p>
            
            <p class="card-text">
              Picking an object will select it and display in the right-handed sidebar.<br />
              Picking a tile while an object is already selected will move the object to the selected tile.
            </p>
            
            <p class="card-text">
              Now that you've added a new NPC to the level, let's configure it to use the script we created earlier:
            </p>
            
            <video class="card-img-top" src="videos/05-character-set-script.webm" autoplay loop controls muted></video>
            
            <p class="card-text warning">
              Don't forget to click the <b>Save</b> button on the bottom-right side of the screen in order to save your changes.
            </p>
            
            <p class="card-text">
              Once your changes have been saved, if you launch a new game, your NPC will be there waiting for you. It's not doing much yet though: let's fix that !
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-4">3.4 Interactions and Text bubbles</h4>
            
            <p class="card-text">
              Your NPCs can talk directly to the player, using the dialog system, but they can also speak outside of the dialog interface, using text bubbles. Text bubbles are displayed on top of a character's sprite for a given amount of time. Text color is used to express the emotion of the character.
            </p>
            
            <p class="card-text">
              We want our NPC to say something specific when the player tries to talk with it. First, we need to setup the script to let the game engine know that our NPC can talk, by overloading the <span class="mono-span">getAvailableInteractions</span> method as following:
            </p>
            
<div class="code-header">scripts/npcs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  constructor(model) {
    super(model);
  }
  
  getAvailableInteractions() {
    const interactions = super.getAvailableInteractions();
    
    if (!level.combat)
      interactions.unshift("talk-to");
    return interactions;
  }
}</code></pre>

            <p class="card-text">
              Now, when the player opens the interaction menu, the first interaction in the list will be the <span class="mono-span">talk-to</span> interactions.
            </p>
            
            <p class="card-text card-hint">
              Available interactions are:
              <span class="mono-span">talk-to</span>
              <span class="mono-span">push</span>
              <span class="mono-span">look</span>
              <span class="mono-span">use</span>
              <span class="mono-span">use-object</span>
              <span class="mono-span">use-spell</span>
              <span class="mono-span">use-skill</span>
              <br/>
              Note that use-object, use-spell and use-skill are slightly different from other interactions, and will be covered in another chapter.
            </p>
            
            <p class="card-text">
              Now that our script makes the <span class="mono-span">talk-to</span> interaction available to the player, we need to implement a behaviour for that interaction.<br/>
              This is done by adding a method to your script, which name is relative to the interaction you want to react to. For the <span class="mono-span">talk-to</span> interaction, the method shall be named <span class="mono-span">onTalkTo</span>. Here's how we'll use it:
            </p>
            
<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  constructor(model) {
    super(model);
  }
  
  getAvailableInteractions() {
    const interactions = super.getAvailableInteractions();
    
    if (!level.combat)
      interactions.unshift("talk-to");
    return interactions;
  }
  
  onTalkTo() {
    level.addTextBubble(this.model, "Hello world !", 3000, "lightgreen");
    return true;
  }
}</code></pre>

            <p class="card-text">
              To display our text bubble, we called the <span class="mono-span">level.addTextBubble</span> function.<br />
              <ul>
                <li>The first parameter is the object managed by your script. It is available within your script as <span class="mono-span">this.model</span>.</li>
                <li>The second parameter is the text you want to be displayed.</li>
                <li>The third parameter is the duration the bubble will remain visible, expressed in milliseconds</li>
                <li>The last parameter is optional, and defines the text color. If none is provided, the text color will be white.</li>
              </ul>
            </p>

            <p class="card-text">
              Our method also returns <span class="mono-span">true</span>: this is optional, but ensures that the game engine's default behaviour for the targeted interaction won't run.
            </p>
            
            <h4 class="card-title" id="c3-5">3.5 Statistics checks and Inspection</h4>
            
            <p class="card-text">
              Sometimes, you will want the outcome of a given action to be determined by the player's character statistics. We'll showcase how to access a character statistics by implementing a custom behaviour for the <span class="mono-span">look</span> interaction, that will show additional details to the player if his character has enough perception:
            </p>
            
<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  constructor(model) {
    super(model);
  }
  
  getAvailableInteractions() {
    const interactions = super.getAvailableInteractions();
    
    if (!level.combat)
      interactions.unshift("talk-to");
    return interactions;
  }
  
  onTalkTo() {
    level.addTextBubble(this.model, "Hello world !", 3000, "lightgreen");
  }
  
  onLook() {
    const isPerceptiveEnough = game.player.statistics.perception > 5;
    
    if (isPerceptiveEnough)
      game.appendToConsole("You see " + this.model.statistics.name + ". He looks positively dazzling today.");
    else
      super.onLook();
  }
}</code></pre>

            <p class="card-text">
              In this snippet, we added a <span class="mono-span">onLook</span> method to implement a custom behaviour for inspection.
            </p>
            <p class="card-text">
              It starts by accessing the player's statistic sheet using <span class="mono-span">game.player.statistics</span>. Note that the player object is always available through the <span class="mono-span">game</span> global object.
            </p>
            <p class="card-text">
              We then check if the character perception is above 5: if it is, we display our own custom message on the game console using <span class="mono-span">game.appendToConsole</span>. Otherwise, we fallback to the default behaviour by calling <span class="mono-span">super.onLook()</span>.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-6">3.6 Movement and actions</h4>
            
            <p class="card-text">
              To move a character or perform action, you need to use the character's action queue. The action queue allows you to define series of actions to perform. It supports the following actions:
              <span class="mono-span">Movement</span>,
              <span class="mono-span">Reach</span>,
              <span class="mono-span">ItemUse</span>,
              <span class="mono-span">SpellUse</span>,
              <span class="mono-span">SkillUse</span>.
            </p>
            
            <p class="card-text">
              In the following code, we will set up our NPC to follow the player, using the <span class="mono-span">Reach</span> action.
            </p>

<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  initialize() {
    this.model.tasks.addTask("followPlayer", 5000, 0);
  }
  
  followPlayer() {
    const requiredDistance = 3;
    const distance = this.model.getDistance(game.player);
    
    if (distance > requiredDistance) {
      const actions = this.model.getActions();

      actions.reset();
      actions.pushReach(game.player, requiredDistance);
      actions.start();
    }
  }
}</code></pre>

            <p class="card-text">
              We first schedule a task that will get called every five seconds.
            </p>

            <p class="card-text warning">
              Don't forget to schedule such recurrent tasks in the <span class="mono-span">initialize</span> method, rather than in the constructor. Otherwise, the task would be scheduled each time the character gets instantiated, resulting in a lot more calls to your target method than you probably hoped for.
            </p>
            
            <p class="card-text">
            In the <span class="mono-span">followPlayer</span> method, we order our NPC to ensure that the distance between him and the player is less than 3. When the distance goes over the limit, we fetch the action queue using <span class="mono-span">this.model.getActions()</span>, and set up a <span class="mono-span">Reach</span> action.
            </p>
            
            <p class="card-text">
            When using the action queue, you probably will want to interrupt any action that might already be running. To do so, we call <span class="mono-span">actions.reset()</span> before scheduling any new actions.
            </p>
            
            <p class="card-text">
            The <span class="mono-span">Reach</span> action is scheduled using <span class="mono-span">pushReach</span>. The first parameter is the object you want your character to move towards. The second parameter is the maximum distance you wish to keep with the object.<br />
            </p>
            
            <p class="card-text card-hint">
            The <span class="mono-span">Reach</span> action ensures that your character will have a line of sight with the targeted object, meaning it's useful for following, interacting with objects, or finding the proper position to shoot ranged weapons.
            </p>
            
            <p class="card-text">
            Finally, we call <span class="mono-span">actions.start()</span> to trigger the action queue: it will then execute each actions consecutively, until one of them fails, or until the queue is empty. In both cases, your ma implement a <span class="mono-span">onActionQueueCompleted</span> method, and it will get called whenever the action queue is interruped or completed.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-7">3.7 Combat and Diplomacy</h4>
            
            <h5 class="card-title" id="c3-7-1">3.7.1 Combat basics</h5>

            <p class="card-text">
            We will now start our first combat, and write a simple strategy for our NPC that will consist in running for dear life, away from the player. Then, we will see how to make our own NPC start the combat, by using the Diplomacy features.
            </p>
            
            <p class="card-text">
            There are three methods you script need to implement to properly react during combat:
            <ul>
              <li><span class="mono-span">onTurnStart</span> gets called when your NPC's turn start</li>
              <li><span class="mono-span">onActionQueueCompleted</span> which we talked about in chapter 2.6, will get triggered once your actions have been executed. In combat, you should use this callback to schedule new actions, or pass your turn.</li>
              <li><span class="mono-span">onDamageTaken</span> is called when your NPC takes damage. You may use it to pick the most dangerous target for your NPC</li>
            </ul>
            </p>
            
            <p class="card-text">
              Let's see those methods in action:
            </p>

<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  onDamageTaken(damage, attacker) {
    this.fleeingCharacer = attacker;
  }
  
  onTurnStart() {
    const isThreatened = this.fleeingCharacter && this.model.hasLineOfSight(this.fleeingCharacter);
  
    if (isThreatened) {
      this.model.movementMode = "running";
      this.model.moveAway(this.fleeingCharacter);
    }
    else
      level.passTurn(this.model);
  }
}</code></pre>

            <p class="card-text">
              As you can see, we used <span class="mono-span">onDamageTaken</span> to set a character our NPC will flee from.<br/>
              Then, in <span class="mono-span">onTurnStart</span>, we check if our NPC has a character to flee from. If it doesn't, we immedately call <span class="mono-span">level.passTurn(this.model)</span> to skip our NPC's turn.
            </p>
            
            <p class="card-text">
              When our <span class="mono-span">isThreatened</span> evaluates to <span class="mono-span">true</span>, we set <span class="mono-span">movementMode</span> on our model to trigger the running mode. Characters are walking by default, and you can switch between these two modes whenever you want.<br />
              After setting the movement mode, we call <span class="mono-span">this.model.moveAway</span>: that method is a helper to move one case away from a given character. Under the hood, it also uses the action queue, which means that <span class="mono-span">onActionQueueCompleted</span> will also get called once the NPC has moved.
            </p>
            
            <p class="card-text">
              In the current state of affairs, if you were to launch a game and start a fight with that NPC, the game would get blocked, because your NPC doesn't ever finish his turn.<br/>
              There are two ways to finish a turn: spending all your action points, or calling <span class="mono-span">level.passTurn</span>. In the following code, we'll add a <span class="mono-span">onActionQueueCompleted</span> method to order our NPC to keep running away, or pass its turn:
            </p>
            
<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  onDamageTaken(damage, attacker) {
    this.fleeingCharacer = attacker;
  }
  
  onTurnStart() {
    this.tryToRunAway();
  }
  
  onActionQueueCompleted() {
    if (level.combat)
      this.tryToRunAway();
  }
  
  tryToRunAway() {
    const isThreatened = this.fleeingCharacter && this.model.hasLineOfSight(this.fleeingCharacter);
  
    if (isThreatened) {
      this.model.movementMode = "running";
      this.model.moveAway(this.fleeingCharacter);
      if (this.model.getActions().isEmpty())
        level.passTurn(this.model);
    }
    else
      level.passTurn(this.model);
  }
}</code></pre>

            <p class="card-text">
              We moved the code previously in <span class="mono-span">onTurnStart</span> to a new custom method, <span class="mono-span">tryToRunAway</span>.<br />
              We then call this method both on turn start or when the action queue is completed. Note that, when the action queue is completed, we also check if a combat is currently happening by checking the <span class="mono-span">level.combat</span> variable. That is because the action queue callback get called both in and outside combat, whenver the action queue is depleted.
            </p>
            
            <p class="card-text">
              This new code also handles another scenario: what if our NPC is stuck and cannot move away ? Then, the action queue won't be able to start, it will be empty, even after calling <span class="mono-span">moveAway</span>... and our NPC won't ever pass his turn.<br/>
              To prevent that from happening, we check that the action queue is active by calling <span class="mono-span">this.model.getActions().isEmpty()</span>. If the action queue is empty, we pass our NPC turn by calling <span class="mono-span">level.passTurn(this.model)</span>.
            </p>
            
            <h5 class="card-title" id="c3-7-2">3.7.2 Diplomacy</h5>
            
            <p class="card-text">
              Now that we know how to make our NPC behave in combat, let's have a little talk about how NPCs detect friendly or unfriendly characters, and start fights on their own.
            </p>
            
            <p class="card-text">
              The character sheet defines a faction for each characters. A faction is optional, but most NPC should have one: an NPC without a faction can recognize his own enemies, but he cannot be recognized as an enemy by other NPCs, as only Factions can be defined as enemies (individual characters cannot).
            </p>
            
            <p class="card-text">
              Each character has its own list of enemies. Each faction has its own list of enemies. And each character may be part of one faction.<br/>
              This behaviour has been implemented to allow infiltration scenarios, in which some characters might fight against the player, but the faction may not be warned about the change in relationship unless the player doesn't manage to get rid of all the witnesses.
            </p>
            
            <p class="card-text">
              Now that we've covered the basics principles of diplomacy, let's edit our NPC code and see how to leverage it to have our NPC trigger a combat:
            </p>
            
<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  get fleeingCharacter() {
    return game.player;
  }
  
  getAvailableInteractions() {
    const interactions = super.getAvailableInteractions();
    
    if (!level.combat)
      interactions.unshift("talk-to");
    return interactions;
  }

  onTalkTo() {
    level.addTextBubble(this.model, "Catch me if you can !", 3000, "yellow");
    this.model.setAsEnemy(game.player);
  }

  onTurnStart() {
    this.tryToRunAway();
  }
  
  onActionQueueCompleted() {
    if (level.combat)
      this.tryToRunAway();
  }
  
  tryToRunAway() {
    const isThreatened = this.fleeingCharacter && this.model.hasLineOfSight(this.fleeingCharacter);
  
    if (isThreatened) {
      this.model.movementMode = "running";
      this.model.moveAway(this.fleeingCharacter);
      if (this.model.getActions().isEmpty())
        level.passTurn(this.model);
    }
    else
      level.passTurn(this.model);
  }
}</code></pre>

            <p class="card-text">
              There are two new things to notice here:
            </p>
            
            <p class="card-text">
              First, as our NPC's threat is no longer defined by who previously attacked him, the <span class="mono-span">fleeingCharacter</span> variable is no longer defined in <span class="mono-span">onDamageTaken</span>, but in a getter that always returns the player character.
            </p>
              
            <p class="card-text">
              Then, we added a custom handler for the <span class="mono-span">onTalkTo</span> interaction, as we had done in chapter 2.4. In this custom handler, we called <span class="mono-span">this.model.setAsEnemy(game.player)</span>. After that method is called, your NPC and player will detect each other as enemies. NPCs start a fight whenever an enemy enters their field of view.
            </p>

            <p class="card-text warning">
              You may have noticed that you can also set several NPCs as enemies. Be careful though: it will only work if at least one of the NPC is part of a faction.
            </p>
            
            <p class="card-text">
              If all went well, this is what interactions between our player and NPC should now look like:
            </p>

            <video class="card-img-top" src="videos/06-npc-fleeing.webm" autoplay loop controls muted>
            </video>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-8">3.8 Data storage</h4>
            
            <p class="card-text">
              Often, you will need to save data that will remain accessible as the player exits a level, save and load a game, and so on...<br/>
              And the thing is, while properties on game objects<i>*</i> are always saved by the game engine, the properties that you set on your scripts aren't saved between multiple loads of your script.
            </p>
            
            <p class="card-text card-hint">
              <i>Game objects</i> are the native objects provided by the game engine itself. The parameter received by in the <span class="mono-span">export function create(model)</span> function is an example of game object.
            </p>
            
            <p class="card-text">
              To answer all your data saving needs, all game objects come with a data store, meaning that you can save data globally, using the <span class="mono-span">game</span> global property. You can also save data on a specific level, using the <span class="mono-span">level</span> global property. And you can also save data on specific characters, items, objects of all kinds.
            </p>
            
            <p class="card-text">
              Using the data storage features is pretty easy: there are only three method names you need to memorize. We will present the three of those in the following snippet:
            </p>
 
<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>import {CharacterBehaviour} from "./character.mjs";

const textBubbles = [
  "first message",
  "second message",
  "third message"
];

class Npc extends CharacterBehaviour {
  onTalkTo() {
    var value = 0;
  
    if (this.model.hasVariable("myVariable"))
      value = this.model.getVariable("myVariable");
    if (value < textBubbles.length) {
      level.addTextBubble(this.model, textBubbles[value], 5000);
      return true;
    }
    return false;
  }
}

export function create(model) {
  return new Npc(model);
}</code></pre>

            <p class="card-text">
              With that new <span class="mono-śpan">onTalkTo</span> method, we ensure that our character will consistantly react to talk-to interactions by successively speaking each line in the <span class="mono-span">textBubbles</span> array.
            </p>
            
            <p class="card-text">
              You could achieve the same behaviour with JavaScript properties... but it wouldn't work anymore as a player leaves and rejoin the level your NPC is in, or if the player saves and loads the game. Thanks to the <span class="mono-span">hasVariable</span>, <span class="mono-span">getVariable</span> and <span class="mono-span">setVariable</span> methods, the state of our NPC will be preserved.
            </p>

          </div>
        </div>
        
        <h2 class="my-4" id="c4">
          4. Dialogs
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title" id="c4-1">4.1 Creating a new dialog</h4>
            
            <p class="card-text">
              We will now create a minimalist dialog, teaching you the basics of dialogs. Start by opening the dialog editor in the game editor, and create a new dialog, as following:
            </p>

            <video class="card-img-top" src="videos/07-create-dialog.webm" autoplay loop controls muted>
            </video>
            
            <div class="end-chapter"></div>

            <h4 class="card-title" id="c4-2">4.2 Lines and answers</h4>
            
            <p class="card-text">
              A dialog is basically a set of <i>states</i> and <i>answers</i>. The dialog starts in a given state, and the player then move through states by selecting answers.
            </p>
            
            <h5 class="card-title" id="c4-2-1">4.2.1 States</h5>

            <p class="card-text">
              We must then create a first state, which will serve as the entry point for our dialog, and will be the first state to load when the player initiates a dialog:
            </p>

            <video class="card-img-top" src="videos/08-create-dialog-state.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text">
              A new interface popped up, allowing you to preview the current state and its answers. Dialogs work with a translation system, which implies that we will first define a translation key, before providing a translation for it. The following video shows you how to set the translation key for the current state:
            </p>
            
            <video class="card-img-top" src="videos/09-create-dialog-state-set-text.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text">
              And now, we add the corresponding translation using the <i>translate</i> button:
            </p>
            
            <video class="card-img-top" src="videos/10-create-dialog-state-translate-text.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text card-hint">
              The <i>translate</i> button will create a translation for the language currently configured in the game. Use the <i>options</i> menu entry on the main menu to configure the current language.
            </p>
            
            <p class="card-text card-hint">
              Translations are stored in the <span class="mono-span">assets/locales</span> folder, using JSON format. You can also edit these files manually.
            </p>
            
            <p class="card-text">
              Before moving on to the next step, please create a second state for your dialog: we will see in the next sub-section how to move from one state to the other.
            </p>
            
            <h5 class="card-title" id="c4-2-2">4.2.2 Answers</h5>
            
            <p class="card-text">
              We will now see how to create and configure answers. There are several important facts about answers you need to know:
              
              <ul>
                <li>Answers are optional. If no answer is defined for a given state, the dialog will generate a single answer that the player may use to leave the dialog.</li>
                <li>Answers are shared between states. If you use the same name for two answers in two different states, changes to one of the answer will also affect the other one.</li>
                <li>Default behaviour for an answer is to redirect to another state. If no state is set, the dialog will close when the player picks that answer.</li>
              </ul>
            </p>
            
            <p class="card-text">
              Now that we've cleared that up, let's add our first answer. Click the <i>Add answer</i> button on the bottom part of the screen, and create a new answer.
            </p>
            
            <p class="card-text">
              The new interface that popped up can be used to customize our answer. Start by setting a translation key and providing a translation, just as we did for the current state text.
            </pa>
            
            <p class="card-text">
              By default, the answer does not have any target state, meaning that it's only effect is to end the dialog. Let's configure that answer so that it redirects the dialog to the second state we created earlier:
            </p>

            <video class="card-img-top" src="videos/11-create-dialog-set-answer-state.webm" autoplay loop controls muted>
            </video>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c4-3">4.3 Binding a dialog on a NPC</h4>
            
            <p class="card-text">
              Our minimalist dialog is ready to be used in game. We first need to bind it to a NPC: let's use the NPC we created in Chapter 2. Update the code as following:
            </p>
            
<div class="code-header">scripts/npcs/myNpc.mjs</div>
<pre class="code"><code>import {CharacterBehaviour} from "./character.mjs";

class Npc extends CharacterBehaviour {
  constructor(model) {
    super(model);
    this.dialog = "myDialog";
  }
}

export function create(model) {
  return new Npc(model);
}
</code></pre>

            <p class="card-text">
              It's as simple as that: just set the dialog property on your script in the constructor. Note that we don't need to overload <span class="mono-span">getAvailableInteractions</span> anymore, as the default behaviour for that method is to include the <span class="mono-span">talk-to</span> interaction when a dialog is set.
            </p>
            
            <p class="card-text warning">
              Properties such as <span class="mono-span">dialog</span> should not be set in your script <span class="mono-span">initialize</span> method, or else your dialog would only be available the first time the character load.
            </p>
            
            <p class="card-text">
              Everything is ready for a test run. This is the result of what we've done so far:
            </p>
            
            <video class="card-img-top" src="videos/12-basic-dialog-example.webm" autoplay loop controls muted>
            </video>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c4-4">4.4 Scripting dialogs</h4>
            
            <p class="card-text">
              This is all well and fine, but un-scripted dialogs can only lead us so far. We will now learn how to implement more complex behaviour using the dialog's script.<br/>
              The dialog script file has been created back when we created the dialog in section 3.1. Open the file at <span class="mono-span">scripts/dialogs/myDialog.mjs</span>:
            </p>
            
            <div class="code-header">scripts/dialogs/myDialog.mjs</div>
<pre class="code javacsript"><code>class Dialog {
  constructor(dialog) {
    this.dialog = dialog;
  }
}

export function create(dialog) {
  return new Dialog(dialog);
}</code></pre>

            <p class="card-text">
              The first thing to know is that you have access to the NPC character object through <span class="mono-span">this.dialog.npc</span>. Dialogs are not persistent, so any information you wish to store about a dialog should be stored within the NPC character object.
            </p>
            
            <p class="card-text">
              Scripting dialogs mostly amounts to creating callbacks that you then configure for each state and answers in the Dialog Editor. Here's a list of callbacks and what you can do with those:
              
              <style>
              .dialog-hook-table {
                width: 100%;
              }
              
              .dialog-hook-table tr {
                border: 1px solid gray;
              }
              
              .dialog-hook-table td {
                padding: 5px;
                vertical-align: top;
                border: 1px solid gray;
              }
              </style>
              
              <table class="dialog-hook-table">
                <tr>
                  <th>Callback</th>
                  <th>Return value</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>getEntryPoint</td>
                  <td>state name</td>
                  <td>Implement this method to programmaticaly define the first state of a dialog. If the method isn't implemented, or doesn't return a state name, the initial state set in the dialog editor will be used instead.</td>
                </tr>
                <tr>
                  <td>Available callbacks</td>
                  <td>boolean</td>
                  <td>Available callbacks are methods you may define on answers, allowing you to programmaticaly define whether the answer will be visible to the player or not.<br/>
                  Available hooks are called when a state loads.
                </tr>
                <tr>
                  <td>State trigger callbacks</td>
                  <td>text or object</td>
                  <td>Use these callbacks if you want to programmatically define the text for a state. Optionally, you may also return a JavaScript object, allowing you to set both the text and the answers for the state.
                </tr>
                <tr>
                  <td>Answer trigger callbacks</td>
                  <td>state name</td>
                  <td>These callbacks are called when a player picks an answer. They allow you to programmatically override the default target state for the answer.</td>
                </tr>
                <tr>
                  <td>Answer text callback</td>
                  <td>text</td>
                  <td>Use these callbacks to programmatically define the text for an answer</td>
                </tr>
              </table>
            </p>

            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c4-5">4.5 Setting the mood</h4>
            
            <p class="card-text">
              Dialogs can also have an ambiance and a specific mood. The ambiance is the background displayed behind the character's face, while the mood determines how the face is rendered.
            </p>
            
            <p class="card-text">
              Available ambiances are stored in <span class="mono-span">assets/faces/backgrounds</span>, and you may also add your own, using the PNG format.
            </p>
            
            <p class="card-text">
              The following snippet customizes our dialog to use the <i>wasteland</i> ambiance:
            </p>

            <div class="code-header">scripts/dialogs/myDialog.mjs</div>
<pre class="code javacsript"><code>class Dialog {
  constructor(dialog) {
    this.dialog = dialog;
    this.dialog.ambiance = "wasteland";
  }
}

export function create(dialog) {
  return new Dialog(dialog);
}</code></pre>

            <p class="card-text">
              Moods will typically change in your <i>state trigger callbacks</i>, but for the purpose of the exemple, we'll also set a mood for our NPC on dialog creation in the following code:
            </p>
            
            <div class="code-header">scripts/dialogs/myDialog.mjs</div>
<pre class="code javacsript"><code>class Dialog {
  constructor(dialog) {
    this.dialog = dialog;
    this.dialog.ambiance = "wasteland";
    this.dialog.mood = "smile";
  }
}

export function create(dialog) {
  return new Dialog(dialog);
}</code></pre>

            <p class="card-text">
              Available moods are: <i>angry, cocky, neutral, sad, smile</i>.
            </p>
            
          </div>
        </div>
        
        <h2 class="my-4" id="c5">
          5. Game Objects
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title" id="c5-1">5.1 Introduction</h4>
          
            <p class="card-text">
              Game Objects are the objects populating the world: characters, doors, items, and anything that the player can interact with. All of them can be controlled by a script, and they all share a set of tools to help you program their behaviour:
            </p>
            
            <table class="dialog-hook-table">
              <tr>
                <td>Sprite</td>
                <td>The visual representation of a game object on the tilemap.</td>
              </tr>
              <tr>
                <td>Script</td>
                <td>Scripts are attached to their game objects, and can be interacted with by other scripts.</td>
              </tr>
              <tr>
                <td>Detectability</td>
                <td>By default, objects are visible. But they can be hidden, and revealed through script or detection.</td>
              </tr>
              <tr>
                <td>DataStore</td>
                <td>Persistent data are written in DataStore, as seen in <a href="#c3-8">section 2.8</a>.</td>
              </tr>
              <tr>
                <td>ControlZone</td>
                <td>Objects can optionally feature a control zone, defined in the Game Editor. Control zones can signal the script when characters enter the zone. They can also block or release access to the zone.</td>
              </tr>
              <tr>
                <td>TaskManager</td>
                <td>Allows you to schedule calls to your scripts. It is based on game-time, rather than real-time.<br/>The <span class="mono-span">game</span> and </span class="mono-span">level</span> global objects also feature a TaskManager, and we've experimented with it in section <a href="#c1-4">1.4</a> and <a href="#c3-6">2.6</a>.</td>
              </tr>
            </table>

            <p class="card-text" style="margin-top:20px">
              In our journey to discover game objects, we will start with the simplest of them all: we call it the DynamicObject, and it serves as a basis for all interactive objects.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c5-2">5.2 Sprite and positionning</h4>

            <p class="card-text">
              Our first DynamicObject will be a puddle of acid. We will use this example to learn how control zones work. Our first step will be to create a Sprite for our object. We will use the following picture to represent our puddle:
            </p>
            
            <img src="pictures/acid.png" />
            
            <p class="card-text">
              Download this file to your <span class="mono-span">assets/sprites</span> folder. Then, open up the Game Editor, go to the Sprite tab, and create our new sprite as following:
            </p>
            
            <video class="card-img-top" src="videos/13-create-sprite.webm" autoplay loop controls muted></video>
            
            <p class="card-text">
              Sprites are organized in groups. Objects usually use sprites from a single group. Here, we created a sprite group named <i>acid-puddle</i>, and added the <i>normal</i> animation to it.
            </p>
            
            <p class="card-text">
              Now that our sprite has been created, let's create a generic object in the level editor. When creating an object, we will select the "Other" category, to tell the level editor we're creating a custom DynamicObject.
            </p>
            
            <p class="card-text">
              Then, we will set a position on the map, and select the sprite we created. See the following video for reference:
            </p>
            
            <video class="card-img-top" src="videos/14-create-acid-puddle-01.webm" autoplay loop controls muted></video>
            
            <p class="card-text">
              Our acid puddle is now rendered in the level. But it's not exactly properly positionned. Characters are going to walk on that puddle, and we want it to be properly rendered below the characters, and not above.
            </p>
            
            <p class="card-text">
              For these kind of situations, we will use the Floating positionning mode, as opposed to the Tile-based one. A tile position will still be required, as it is necessary to determine render order. But we will set the position manually, as following:
            </p>
            
            <video class="card-img-top" src="videos/15-create-acid-puddle-02.webm" autoplay loop controls muted></video>
            
            <p class="card-text card-hint">
              Since the rendering order starts with objects from the top and right positions, you should ensure the tile position of your floating objects is set to the upper right tile overlapped by your object.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c5-3">5.3 Control zones</h4>
            
            <p class="card-text">
              Now that our puddle is rendered on screen, we will need a way for it to know when characters are moving around in it. Luckily, that is one of the feature of the control zones. We will now set our sights on creating a control zone, and interacting with it using a script.
            </p>
            
            <p class="card-text">
              Let's configure our control zone first. Create a control zone for the puddle, like this:
            </p>
            
            <video class="card-img-top" src="videos/16-create-acid-puddle-03.webm" autoplay loop controls muted></video>
            
            <p class="card-text">
              The first thing we did here was unchecking the <i>Blocks path</i> checkbox: by default, control zones block access to the zone cases. But we want characters to walk on our puddle, so our zone must be accessible.
            </p>
            
            <p class="card-text">
              Then, we toggled the zone edit mode: when the zone edit mode is enabled, clicking on tiles will add them to the control zone.
            </p>
            
            <p class="card-text">
              The next step is to create script that will put this control zone to use. Create the following script:
            </p>
            
            <div class="code-header">scripts/behaviour/acidPuddle.mjs</div>
            <pre class="code javascript"><code>class AcidPuddle {
  constructor(model) {
    this.model = model;
  }
  
  initialize() {
    this.model.blocksPath = false;
  }
}

export function create(model) {
  return new AcidPuddle(model);
}</code></pre>

            <p>
              In the <span class="mono-span">initialize</span> method, we set <span class="mono-span">this.model.blocksPath</span> to false: by default, objects block access to the tile they are occupying. You can toggle that behaviour by setting this property.
            </p>
            
            <p>
              Now, let's say we want our acid puddle to inflict damage on characters as they enter or exit the zone: to achieve that, we can overload the methods <span class="mono-span">onZoneEntered</span> and <span class="mono-span">onZoneExited</span>:
            </p>
            
            <pre class="code javascript"><code>class AcidPuddle {
  constructor(model) {
    this.model = model;
  }
  
  initialize() {
    this.model.blocksPath = false;
  }
 
  onZoneEntered(character) {
    this.inflictBurn(character);
  }
   
  onZoneExited(character) {
    this.inflictBurn(character);
  }
   
  inflictBurn(character) {
    if (character == game.player)
      game.appendToConsole("The acid is slowly disolving you !");
    character.takeDamage(10);
  }
}

export function create(model) {
  return new AcidPuddle(model);
}</pre></code>

            <p class="card-text">
              With that example, we know how to make our object react to characters entering or leaving its control zone. But what if we want to inflict damage over time to the characters that are already within the zone ?
            </p>
            
            <p class="card-text">
              We will update our acid puddle script to inflict damage to the residents of its control zone over time. For that, we will use the <span class="mono-span">getControlZoneOccupants</span> method from our game object, conjointly with its Task Manager:
            </p>
            
            <pre class="code javascript"><code>class AcidPuddle {
  constructor(model) {
    this.model = model;
  }
  
  initialize() {
    this.model.blocksPath = false;
    this.model.tasks.addTask("inflictBurn", 3500, 0);
  }
 
  inflictBurn() {
    const occupants = this.model.getControlZoneOccupants();
    const characters = occupants.filter(object => object.getObjectType() == "Character");

    characters.forEach(character => character.takeDamage(10, null));
  }
}

export function create(model) {
  return new AcidPuddle(model);
}</pre></code>

            <p class="card-text">
              The <span class="mono-span">getControlZoneOccupants</span> method returns a list of all the objects in a zone: but we only care about characters, which is why we filtered out the non-character objects using <span class="mono-span">getObjectType</span>.<br />
              Then, we iterate over each character and inflict damage to them by calling <span class="mono-span">takeDamage</span>.
            </p>
            
            <p class="card-text hint">
              <span class="mono-span">takeDamage</span> takes two parameters: the first one for the amount of damage inflicted, while the second one is meant to indicate which other character inflicted the damage. When damage hasn't been inflicted by any character in particular, you can just pass <span class="mono-span">null</span> instead.
            </p>

            <p class="card-text">
              Set the script for our object, as we previously did in <a href="#c3-3">section 2.3</a>: if you start a new game and walk on our puddle, you should take 10 points of damage every 3.5 seconds.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c5-4">5.4 Detectability</h4>
            
            <p class="card-text">
              Sometimes, objects should be concealed to the player. Concealed objects can be revealed through script, or through detection by the player. Detection is based on the player's Perception and the distance between the player and the object.
            </p>
            
            <p class="card-text">
              If we edit the <span class="mono-span">initialize</span> method of our script as below, we will make our object invisible to the player until we manually reveal it later. We do this by setting the <span class="mono-span">this.model.hidden</span> property:
            </p>
            
<pre class="code"><code>
  initialize() {
    this.model.hidden = true;
    this.model.blocksPath = false;
    this.model.tasks.addTask("inflictBurn", 3500, 0);
  }
</code></pre>

            <p class="card-text">
              What if we want to enable detectability for the player ? To do that, we'll use <i>sneaking</i>, as following:
            </p>

<pre class="code"><code>
  initialize() {
    this.model.toggleSneaking(true);
    this.model.interruptOnDetection = true;
    this.model.blocksPath = false;
    this.model.tasks.addTask("inflictBurn", 3500, 0);
  }
  
  onDetected() {
    game.appendToConsole("You detected a puddle of acid");
  }
</code></pre>

            <p class="card-text">
              Note that we also set <span class="mono-span">interruptOnDetection</span> to <span class="mono-span">true</span>: this will cause the detection to interrupt whatever the player is currently doing. It is useful to prevent the player from trigerring a trap that he just detected.
            </p>
            
            <p class="card-text">
              We also added the <span class="mono-span">onDetected</span> method, which is called whenever concealed objects are detected.
            </p>
            
            <p class="card-text">
              Well then ! We've worked hard on that puddle of acid. Let's see it in action:
            </p>
            
            <video class="card-img-top" src="videos/17-acid-puddle-demo.webm" autoplay loop controls muted>
            </video>
            
            <div class="end-chapter"></div>
          </div>
        </div>
        
        <h2 class="my-4" id="c6">
          6. Inventory, items and equipment
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title" id="c6-1">6.1 Introduction</h4>
          
            <p class="card-text">
              We will now direct our attention towards the item management system. Items are game objects as well, but unlike other game objects, they can be extracted from the tilemap and stored in an inventory. Moreover, they can be equiped in inventory slots (armor, primary item, secondary item).
            </p>
            
            <p class="card-text">
              An item's behaviour is determined by his <span class="mono-span">itemType</span> property. Item types can be defined in the Game Editor, in the Items tab. Let's have a look at the interface:
            </p>
            
            <a href="pictures/itemEditor.png" target="_blank">
              <img class="card-img-top" src="pictures/itemEditor.png" />
            </a>
            
            <p class="card-text">
              <table class="dialog-hook-table">
                <tr>
                  <td>Type</td>
                  <td>A property meant as a way to filter items by category in inventories.</td>
                </tr>
                <tr>
                  <td>Weight</td>
                  <td>The item weight, used for carry weight checks.</td>
                </tr>
                <tr>
                  <td>Value</td>
                  <td>A value of reference to use for barter. The actual barter value will be calculated using this value and the barter skill value of the player's character and the NPC.</td>
                </tr>
                <tr>
                  <td>Groupable</td>
                  <td>Groupable items can merge together, and have an <span class="mono-span">amount</span> property. It is useful anytime the item's behaviour doesn't require the game object to have a persistent state, as a mean of avoiding cluttered inventories. Note that the groupable property can be overriden by the item's script, and relative to each instance of a given item type.</td>
                </tr>
                <tr>
                  <td>Sprite</td>
                  <td>The sprite is used to represent the object when it is on a tilemap. Item sprites are defined in the Sprite Editor, using the <i>items</i> sprite group. The sprite's size should be 72x36.</td>
                </tr>
                <tr>
                  <td>Icon</td>
                  <td>The icon is used to represent the object when it is in an inventory. Item icons should be stored in <span class="mono-span">assets/icons</span>.</td>
                </tr>
                <tr>
                  <td>Script</td>
                  <td>The scripts for items are located at <span class="mono-span">scripts/items</span>. They're game object scripts, as we've already seen many times so far, but can implement a few more properties and methods related to inventory, equipment and targeting.</td>
                </tr>
              </table>
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c6-2">6.2 Storage Objects</h4>
            
            <p class="card-text">
              Storage objects are game objects featuring an Inventory. Characters, for instance, are a sub-class of Storage objects. In this section, we will create a Storage object to demonstrate how inventories are managed in the game editor.
            </p>
            
            <p class="card-text">
              Open the LevelEditor and create a Storage object, using the <i>locker</i> sprite:
            </p>
            
            <video class="card-img-top" src="videos/18-create-storage.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text">
              As you can see, and just like for character objects, storage objects have an <i>Inventory</i> button. It's pretty straightforward to use:
            </p>

            <video class="card-img-top" src="videos/19-looting-editor.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text">
              Plain storage objects don't need a script: our locker is ready to use with just these few steps.<br />
              But what if we want to implement more complex behaviours ? For instance, let's say our NPC owns the locker, and doesn't want us to touch his precious wares ?
            </p>
            
            <p class="card-text">
              Let us write a script that will allow us to do that. We will use <span class="mono-span">onTakeItem</span> and <span class="mono-span">onPutItem</span> to prevent the user to take or put items in our locker, if our NPC sees him do it:
            </p>
            
<div class="code-header">scripts/behaviour/myLocker.mjs</div>
<pre class="code"><code>class MyLocker {
  constructor(model) {
    this.model = model;
  }
  
  onTakeItem(character, item, quantity) {
    return this.preventStealing(character);
  }
  
  onPutItem(character, item, quantity) {
    return this.preventStealing(character);
  }
  
  preventStealing(character) {
    const npc = level.getObjectByName("MyNPC");

    if (npc && npc.isAlive() && npc.hasLineOfSight(character)) {
      level.addTextBubble(npc, "Hey ! Don't touch that !", 4000, "red");
      return false;
    }
    return true;
  }
}

export function create(model) {
  return new MyLocker(model);
}</code></pre>

            <p class="card-text">
              In this code, we overladed both methods and implemented our own method to interrupt the player's attempt to loot on certain condition.<br />
              If the NPC exists and can see the player looting, then we return <span class="mono-span">false</span>, which will prevent the player from taking/putting an item in the inventory, and close the looting interface.
            </p>
            
            <p class="card-text card-hint">
              As characters extend on storage objects, they also feature a <span class="mono-span">onTakeItem</span> and <span class="mono-span">onPutItem</span> methods, which you can use to implement <i>stealing</i> behaviours.
            </p>
            
            <p class="card-text">
              In the Game Editor, configure our storage object to use the <i>myLocker.mjs</i> script we just created. Here's what the result should look like:
            </p>
            
            <video class="card-img-top" src="videos/20-looting-example.webm" autoplay loop controls muted>
            </video>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c6-3">6.3 Creating usable items</h4>
            
            <p class="card-text">
              We will now deep further in the item and inventory scripting tools by creating a consommable item that will temporarily increase a character's Agility.<br/>
              First, we will prepare our item in the item editor, as shown in the video below:
            </p>
            
            <video class="card-img-top" src="videos/21-create-item.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text">
              Now, we will write the script for our item:
            </p>
            
<div class="code-header">scripts/items/agilityPotion.mjs</div>
<pre class="code"><code>import {ItemBehaviour} from "./item.mjs";

class AgilityPotion extends ItemBehaviour {
  constructor(model) {
    super(model);
    this.requiresTarget = false;
    this.triggersCombat = false;
    this.useModes = ["use"];
  }
  
  isValidTarget(object) {
    return object.getObjectType() == "Character";
  }
  
  getActionPointCost() {
    return 2;
  }
}

export function create(model) {
  return new AgilityPotion(model);
}</code></pre>

            <p class="card-text card-hint">
              <span class="mono-span">ItemBehaviour</span>, similarly to <span class="mono-span">CharacterBehaviour</span>, implements default behaviours for all the methods that the game engine might call on Item objects.
            </p>

            <p class="card-text">
              Let's have a look at the properties and methods we've set up, and what they're useful for:
              
              <ul>
                <li><span class="mono-span">requiresTarget</span> is a property you can set on your script to hint that your item does not need a target. Such items can be used directly from inventory.</li>
                <li><span class="mono-span">triggersCombat</span> hints that your item shouldn't be usable outside of combat: activating the item will start combat.</li>
                <li><span class="mono-span">isValidTarget</span> is a method you can implement so the targeting system knows whether a hovered object can be picked as a target or not.</li>
                <li><span class="mono-span">getActionPointCost</span> defines the amount of action point the item will consume if it is used during combat.</li>
              </ul>
            </p>
            
            <p class="card-text">
              Now that we have a usable item, we will overload the default behaviour for the method <span class="mono-span">useOn</span>, to tell the engine what's supposed to happen when the item is used:
            </p>
            
<pre class="code"><code>useOn(target) {
  if (!target)
    target = this.user;
  target.statistics.agility += 1;
}
</code></pre>

            <p class="card-text">
              Since our item doesn't require a target, <span class="mono-span">useOn</span> might be called without a target. For our agility potion, we want the default target to be the one who's using the item: we can fetch this character using <span class="mono-span">this.user</span>, which provided by <span class="mono-span">ItemBehaviour</span>.
            </p>
            
            <p class="card-text">
              Our method then increases the target's agility by one. The change is permanent: if we wanted it to be temporary, we should use a <i>Buff</i>. We'll go over those later.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c6-4">6.4 Inventory</h4>
            
            <p class="card-text">
              We will now give the player our new item as a starting item. We've seen how to manage inventories from the game editor in <a href="#c6-2">5.2 Storage objects</a>. We will now learn how to use inventories from our scripts. Here's the new version of our initialize.mjs file:
            </p>
            
            <div class="code-header">scripts/initialize.mjs</div>
            <pre class="code javascript"><code>function preparePlayerInventory() {
  game.player.inventory.addItemOfType("agility-potion", 2);
}
            
export function initialize() {
  preparePlayerInventory();
  game.onCityEntered("stable-cavern", "demo-begin");
  game.worldmap.setPosition(150, 250);
  game.transitionRequired("intro.mp4", 1);
}</code></pre>

            <p class="card-text">
              We've added a function that accesses the player inventory, and adds two of our new items using <span class="mono-span">addItemOfType</span>.
            </p>
            
            <p class="card-text">
              If you start a new game now, your character will start with two agility potions. But if you use them, you'll notice that they don't get removed from inventory. To fix that behaviour, we'll edit the <span class="mono-span">useOn</span> method from our item script:
            </p>

<div class="code-header">scripts/items/agilityPotion.mjs</div>
<pre class="code"><code>useOn(target) {
  if (!target)
    target = this.user;
  target.statistics.agility += 1;
  this.user.inventory.removeItemOfType(this.model.itemType, 1); // this.model.itemType -> "agility-potion"
}
</code></pre>

            <p class="card-text">
              It is also possible to add or remove items to an inventory using the item's game object, such as <span class="mono-span">this.user.inventory.addItem(this.model)</span> or <span class="mono-span">this.user.inventory.destroyItem(this.model)</span>. Note that, as quantity of items is a property of the game object, using these methods will add or remove all of the items that are grouped together.
            </p>
            
            <p class="card-text">
              We'll go over the remaining features of inventories by adding the possibility of failure to the uses of our potion. The following snippet makes a random check against the user's luck, and drop the bottle on failure:
            </p>
            
 <pre class="code"><code>useOn(target) {
  const dice = Math.random() * this.user.statistics.luck;
  
  if (dice &lt; Math.min(5, this.user.statistics.luck)) {
    this.user.inventory.dropItem(this.model, 1);
    if (this.user.inventory.count("agility-potion") > 0)
      game.appendToConsole("Oh no ! You dropped a potion !");
    else
      game.appendToConsole("Oh no ! You dropped the last potion !");
    return;
  }
  
  if (!target)
    target = this.user;
  target.statistics.agility += 1;
  this.user.inventory.removeItemOfType(this.model.itemType, 1); // this.model.itemType -&gt; "agility-potion"
}</code></pre>

            <p class="card-text">
              With the following code, unless the playing character has maxed his luck statistic, the potion should drop most of the time.<br/>
              The <span class="mono-span">dropItem</span> method doesn't destroy the item: it drops it on the ground, at the inventory's owner position.
            </p>
            
            <p class="card-text">
              We then use the <span class="mono-span">count</span> method, to figure out whether there are potion left or not, and display a message on the HUD console accordingly.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c6-5">6.5 Equipment</h4>

            <p class="card-text">
              Inventories for characters also include <i>item slots</i>. Items can be moved to an inventory to its item slots, and are then considered equiped.<br />
              The item slots available depend on the character race, but they will always include the two quick-use slots: <span class="mono-span">use-1</span> and <span class="mono-span">use-2</span>.
            </p>
            
            <p class="card-text">
              We will explore the realm of equipment by creating an armor. Create a new item called <i>power-armor</i>, using the following icon and script:
            </p>
            
            <img src="pictures/powerarmor.png" title="Art from Setharu"/>
            
<div class="code-header">scripts/items/powerArmor.mjs</div>
<pre class="code"><code>import {ItemBehaviour} from "./item.mjs";

class PowerArmor extends ItemBehaviour {
  constructor(model) {
    super(model);
    this.triggersCombat = false;
    this.useModes = ["use"];
  }
  
  canEquipInSlotType(slotType) {
    return slotType == "armor";
  }
  
  onEquipped(user, on) {
    if (on) {
      user.statistics.strength += 2;
      user.statistics.armorClass += 25;
    }
    else {
      user.statistics.strength -= 2;
      user.statistics.armorClass -= 25;
    }
  }
}

export function create(model) {
  return new PowerArmor(model);
}</code></pre>

            <p class="card-text">
              By default, items can be equiped on the <span class="mono-span">use-1</span> and <span class="mono-span">use-2</span> slots, which are of <span class="mono-span">any</span> type. To change the kind of slots our item can be equipped on, we implemented the <span class="mono-span">canEquipSlotInType</span> method.
            </p>
            
            <p class="card-text">
              The <span class="mono-span">onEquipped</span> method is called on items when they are equipped or unequipped. We used this callback to provide the bonuses of power-armor to its wearer. 
            </p>

            <p class="card-text">
              If you edit <span class="mono-span">initialize.mjs</span> to add our new armor to the player inventory, you should be able to equip it like this:
            </p>

            <video class="card-img-top" src="videos/22-armor-test.webm" autoplay loop controls muted>
            </video>
          </div>
        </div>
        
        <h2 class="my-5" id="c7">
          7. Weapons
        </h2>
        
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title" id="c7-1">7.1 Creating a weapon</h4>
            
            <p class="card-text">
              Now that we have been initiated to item and equipment, we will explore more complex behaviour for items, by developing our first weapon. Create the <i>mouthgun</i> item in the Item Editor, with the following icon and script:
            </p>
            
            <img src="pictures/littlemacintosh.png" alt="Art by Vector-Brony" />

<div class="code-header">scripts/items/mouthGun.mjs</div>
<pre class="code"><code>import {WeaponBehaviour} from "./weapon.mjs";

class MouthGun extends WeaponBehaviour {
  constructor(model) {
    super(model);
    this.useModes = ["shoot", "reload"];
    this.skill = "smallGuns";
  }
  
  get triggersCombat() {
    return this.model.useMode == "shoot";
  }
  
  get requiresTarget() {
    return this.model.useMode == "shoot";
  }
  
  getActionPointCost() {
    if (this.model.userMode == "shoot")
      return 5;
    return 2;
  }
  
  getDamageRange() {
    return [9, 18];
  }
  
  getRange() {
    return 5;
  }
}

export function create(model) {
  return new MouthGun(model);
}</code></pre>

            <p class="card-text">
              Note that we are no longer extending on <span class="mono-span">ItemBehaviour</span>, but on <span class="mono-span">WeaponBehaviour</span>. The latter extends on the former, so all of the item features we learned in the previous chapter are still applicable here.
            </p>
            
            <p class="card-text">
              This time, we set a different value for <span class="mono-span">useModes</span>. Items that can be equiped in <span class="mono-span">use</span> slots can have several use modes that the user can loop through. The current mode of an item is stored in the item game's object, accessible here as <span class="mono-span">this.model.useMode</span>.
            </p>
            
            <p class="card-text">
              Different use modes means different behaviours, which is why we created getters for the <span class="mono-span">requiresTarget</span> and <span class="mono-span">triggersCombat</span> properties, as shooting requires a target and triggers combat, but reloading does not.
            </p>
            
            <p class="card-text">
              In the constructor, we also set the <span class="mono-span">skill</span> property on our script: this is used by <span class="mono-span">WeaponBehaviour</span> to figure out which skill value to use when computing the <i>success rate</i>. Alternatively, it is also used to determine whether the weapon is close-combat or ranged (if set to <i>unarmed</i> and <i>meleeWeapons</i>, the weapon will be considered close-combat).
            </p>
            
            <p class="card-text">
              Weapons have to implement a <span class="mono-span">getDamageRange</span> method, returning an array containing the minimum and maximum amount of damage the weapon can cause.
            </p>
            
            <p class="card-text">
              Lastly, we also implemented <span class="mono-span">getRange</span>, to determine the maximum range of the weapon. A value of 1 is roughly equal to the distance between one tile and another.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c7-2">7.2 Custom use animations</h4>
            
            <p class="card-text">
              Thanks to the default behaviours implemented by <span class="mono-span">WeaponBehaviour</span>, our mouthgun is already usable. But the animation it triggers is the default animation for all interactions, and it doesn't really look like much. We will now see how to implement custom animations for item uses.
            </p>
            
            <p class="card-text">
              Interactions actually happen in two parts: first, an <i>AnimationSequence</i> runs, then a callback from the Item gets triggered. The animation sequence is described by the item script, by the <span class="mono-span">getAnimationSteps</span>: for reference, you can check out the default animation sequence described in <span class="mono-span">scripts/items/item.mjs</span>.
            </p>
            
            <p class="card-text">
              There are two types of animations, and we will use both for our shooting animation:
            </p>
            
            <h5 class="card-title" id="c7-2-1">7.2.1 Object animation</h5>
            
            <p class="card-text">
              Object animations are animations applied on objects, usually on characters. The default animation for all interactions is an Object animation, described as following:
            </p>
            
<pre class="code"><code>{ type: "Animation", animation: "use", object: this.user }</code></pre>

            <p class="card-text">
              The following will result in the item user running the animation <i>use</i> from his sprite group.<br/>
              You might notice that the animation <i>use</i> doesn't exist in the sprite group of your character: instead, you there are several animations called <i>use-up, use-left, use-down, use-right</i>. That's because characters are <i>oriented</i> objects, and their animations are suffixed with the direction to which they are looking.
            </p>

            <p class="card-text card-hint">
              Note that you can manually change the direction a character is looking at, using <span class="mono-span">lookTo(x, y)</span> on the character's game object.
            </p>
            
            <div class="end-chapter"></div>
            
            <h5 class="card-title" id="c7-2-2">7.2.2 Sprite animation</h5>
            
            <p class="card-text">
              The second type of animation are Sprite animations. These will pop a new sprite, which will travel from a beginning to a target position. Here's an example of sprite animation:
            </p>
            
<pre class="code"><code>{
  type: "Sprite",
  name: "effects",
  animation: "explosion",
  fromX: this.user.spritePosition.x,
  fromY: this.user.spritePosition.y,
  toX: target.spritePosition.x,
  toY: target.spritePosition.y
}</code></pre>

            <div class="end-chapter"></div>

            <h5 class="card-title" id="c7-2-3">7.2.3 Setting up an AnimationSequence</h5>

            <p class="card-text">
              Let's now define our own animation sequence, by implementing our own <span class="mono-span">getAnimationSteps</span> for our item:
            </p>
            
<div class="code-header">scripts/items/mouthgun.mjs</div>
<pre class="code"><code>getAnimationSteps(target) {
  if (this.model.useMode == "shoot") {
    return [
      { type: "Animation", animation: "use", object: this.user },
      { type: "Sprite", name: "effects", animation: "explosion", fromX: this.user.spritePosition.x, fromY: this.user.spritePosition.y, toX: target.spritePosition.x, toY: target.spritePosition.y }
    ];
  }
  return super.getAnimationSteps(target);
}</code></pre>

            <div class="end-chapter"></div>

            <h4 class="card-title" id="c7-3">7.3 Dodge and critical failures</h4>
            
            <p class="card-text">
              Dodging and critical failures are handled by <span class="mono-span">WeaponBehaviour</span>, but you can overload these behaviours by implementing the <span class="mono-span">triggerDodgeUse</span> or <span class="mono-span">triggerCriticalFailure</span> methods. Here's an example of dodge implementation:
            </p>
            
<div class="code-header">scripts/items/mouthgun.mjs</div>
<pre class="code"><code>triggerDodgeUse(target) {
  return {
    steps: [
      { type: "Animation", animation: "use", object: this.user },
      { type: "Sprite", name: "effects", animation: "explosion", fromX: this.user.spritePosition.x, fromY: this.user.spritePosition.y, toX: target.spritePosition.x, toY: target.spritePosition.y },
      { type: "Animation", animation: "dodge", object: target }
    ],
    callback: this.onDodged.bind(this, target)
  };
}</code></pre>

            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c7-4">7.4 Reloding weapons</h4>
            
            <p class="card-text">
              We will now see how to implement alternative use modes, by implementing reloading into our weapon. The first thing to do is to create an ammuniton item. We will use the following icon and script:
            </p>
            
            <img src="pictures/9mm-bullets.png" />
            
<div class="code-header">scripts/items/ammo.mjs</div>
<pre class="code"><code>export {ItemBehaviour} from "./item.mjs";

class Ammo extends ItemBehaviour {
}

export function create(model) {
  return new Ammo(model);
}</code></pre>

            <p class="card-text">
              Create the <i>9mm-ammo</i> item in the Item Editor. Make sure the <i>groupable</i> checkbox is checked.
            </p>
            
            <p class="card-text">
              Let's now go back to our <i>mouthgun</i> item. First thing is to set the charger capacity in the item constructor:
            </p>

<div class="code-header">scripts/items/mouthgun.mjs</div>
<pre class="code"><code>constructor(model) {
  super(model);
  this.model.maxAmmo = 6; // &lt;-- here we go
  this.useModes = ["shoot", "reload"];
  this.skill = "smallGuns";
}</code></pre>
            </p>

            <p class="card-text">
              Now, let's add a method that will look for available ammunitions in the inventory, and use it to load the weapon:
            </p>

<div class="code-header">scripts/items/mouthgun.mjs</div>
<pre class="code"><code>onReloaded() {
  const availableAmmo = this.user.inventory.count("9mm-ammo");

  if (availableAmmo > 0) {
    const requiredAmmo = this.model.maxAmmo - this.model.ammo;
    const amount = Math.min(requiredAmmo, availableAmmo);
      
    this.user.inventory.removeItemOfType("9mm-ammo", amount);
    this.model.ammo += amount;
    this.model.useMode = "shoot";
    return true;
  }
  else {
    game.appendToConsole("Out of ammo !");
    this.user.actionPoints += this.getActionPointCost();
  }
  return false;
}</code></pre>

            <p class="card-text">
              We're already familiar with everything used here, except for the <span class="mono-span">this.model.ammo</span> property. It represents the amount of ammunition currently loaded in the weapon.
            </p>
            
            <p class="card-text">
              Note that we restore the user's action point if there was no ammo to load. If ammo has been loaded, we also manually set the item's use mode back to the <span class="mono-span">shoot</span> mode.
            </p>
            
            <p class="card-text">
              We will now implement our new use mode, by overloading the <span class="mono-span">triggerUseOn</span> method: it is called by <span class="mono-span">ItemBehaviour</span>, when preparing the use of an item, and allows us to change the default animation and behaviour. Let's see how to make this work:
            </p>

<div class="code-header">scripts/items/mouthgun.mjs</div>
<pre class="code"><code>triggerUseOn(target) {
  if (this.model.useMode == "reload")
    return { steps: [], callback: this.onReloaded.bind(this) };
  return super.triggerUseOn(target);
}</code></pre>

            <p class="card-text">
              Our <span class="mono-span">triggerUseOn</span> overload can now handle several use modes: for the <span class="mono-span">reload</span> use mode, we make our own <i>AnimationSequence</i> descriptor, and define a custom callback. The <i>AnimationSequence</i> here is empty, which will result in the action being executed immediately. By setting the <span class="mono-span">callback</span> attribute, we're hinting the game engine not to call the default <span class="mono-span">useOn</span> method, after the animation is completed, but our own <span class="mono-span">onReloaded</span> method we implemented earlier.
            </p>
            
            <p class="card-text">
              Now, the last step before we've fully implemented ammo management for our weapon. We need ammo to get used when the weapon is used to shoot. Let's edit <span class="mono-span">triggerUseOn</span> one last time:
            </p>
            
<div class="code-header">scripts/items/mouthgun.mjs</div>
<pre class="code"><code>triggerUseOn(target) {
  if (this.model.useMode == "reload")
    return { steps: [], callback: this.onReloaded.bind(this) };
  if (this.modal.ammo > 0) {
    this.model.ammo -= 1;
    return super.triggerUseOn(target);
  }
  else {
    game.appendToConsole("Out of ammo !");
    this.user.actionPoints += this.getActionPointCost();
  }
  return false;
}</code></pre> 

            <p class="card-text">
              Note that we also check that our charger already has ammo, before using it. If it doesn't, we return <span class="mono-span">false</span>, which will interrupt the item use attempt. We also restore the user action points: indeed, by default, a failed action still consumes action point. If we want the action point to remain, we must restore them.
            </p>
            
            <p class="card-text">
              We've also made sure that using the weapon while it still has ammo will consume 1 ammunition.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c7-5">7.5 Playing sounds</h4>
            
            <p class="card-text">
              Now, our weapon is functional, but it doesn't make any noises. We will learn here how to punctually play sounds. Let's start by adding a reloading sound to our <span class="mono-span">onReloaded</span> method:
            </p>
            
<div class="code-header">scripts/items/mouthgun.mjs</div>
<pre class="code"><code>onReloaded() {
  const availableAmmo = this.user.inventory.count("9mm-ammo");

  if (availableAmmo > 0) {
    const requiredAmmo = this.model.maxAmmo - this.model.ammo;
    const amount = Math.min(requiredAmmo, availableAmmo);
      
    this.user.inventory.removeItemOfType("9mm-ammo", amount);
    this.model.ammo += amount;
    this.model.useMode = "shoot";
    level.sounds.play("reload");
    return true;
  }
  else {
    game.appendToConsole("Out of ammo !");
    this.user.actionPoints += this.getActionPointCost();
    level.sounds.play("out-of-ammo");
  }
  return false;
}</code></pre> 

            <p class="card-text">
              Here, we call <span class="mono-span">level.sounds.play</span> to play a sound when the weapon reloads, and a different sound when it fails to reload. The parameter should be a key registered in the file <span class="mono-span">assets/audio.json</span>, and refers to a file in the <span class="mono-span">assets/audio</span> folder.
            </p>
            
            <p class="card-text">
              <span class="mono-span">WeaponBehaviour</span> also implement handlers for two sounds, used when a weapon triggers, and when a wepaon hits. Usually, these sounds shound be initialized in the weapon's constructor, such as:
            </p>

<div class="code-header">scripts/items/mouthgun.mjs</div>
<pre class="code"><code>constructor(model) {
  super(model);
  this.model.maxAmmo = 6;
  this.useModes = ["shoot", "reload"];
  this.skill = "smallGuns";
  // Initializing weapon sounds below
  this.fireSound = "weapons/gunshot";
  this.hitSound = null;
}</code></pre>

            <p class="card-text">
              The <span class="mono-span">fireSound</span> and <span class="mono-span">hitSound</span> are respectively used when a weapon fires, and when it hits its target.
            </p>
            
            <p class="card-text">
              Our weapon is now ready. Edit <span class="mono-span">scripts/initialize.mjs</span> to add a <i>mouthgun</i> and several <i>9mm-ammo</i> to the player's inventory, and take it for a test run. Here's what it should look like:
            </p>
            
            <video class="card-img-top" src="videos/23-weapon-test.webm" autoplay loop controls muted>
            </video>

            <div class="end-chapter"></div>
            
          </div>
        </div>
        
        <h2 class="my-4" id="c8">
          8. Cutie Mark Acquisition Program
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title" id="c8-1">8.1 Introduction to CMAP</h4>
          
            <p class="card-text">
              CMAP is a sub-system of the game engine that handles character sheets. Each character includes a CMAP powered character sheet, accessible through the <span class="mono-span">statistics</span> property on Character game objects. It features a set of different values for:
            </p>
            
            <p class="card-text">
              <ul>
                <li><b>Face</b>, a set of informations used to draw the face of the character.</li>
                <li><b>Characteristics</b>, the strength, perception, endurance, charisma, intelligence, agility, luck values.</li>
                <li><b>Statistics</b>, a set of values computed from characteristics and other modifiers.</li>
                <li><b>Skills</b>, the level of mastery for each skills.</li>
                <li><b>Perks</b>, bonuses that can be gained sometimes after gaining a level.</li>
                <li><b>Traits</b>, which provide both bonuses and maluses, and can be selected during character creation</li>
                <li><b>Race</b>, which can be used to customize other values, and define which <i>sprite group</i> will be used to render the character.</li>
              </ul>
            </p>
            
            <p class="card-text">
              All of these values can be consulted and modified by scripts. Additionally, traits, races and perks are script-based, and entirely customizable.
            </p>
            
            <p class="card-text">
              All the values can be directly read or overwritten from the character sheet object, accessing them using their full name in lower camelcase, such as:
            </p>
            
<pre class="code"><code>character.statistics.agility
character.statistics.lockpick
character.statistics.armorClass
...
</code></pre>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c8-2">8.2 Experience and levels</h4>

            <p class="card-text">
              Among other things, CMAP handles the experience and level of a character. You may manually grant experience to a character with the following code:
            </p>
            
<pre class="code"><code>character.statistics.addExperience(25);</code></pre>

            <p class="card-text">
              You can also read the current experience, and the experience left until the next level, using the following properties:
            </p>

<pre class="code"><code>character.statistics.experience
character.statistics.xpNextLevel</code></pre>

            <p class="card-text">
              When the next level is reached, the player gains skill points, and sometimes a perk, according to <span class="mono-span">statistics.skillRate</span> and <span class="mono-span">statistics.perkRate</span>, respectively, the amount of skill points gained by level, and the amount of level to pass before gaining a perk.
            </p>
            
            <p class="card-text">
              The current amount of skill points and perks available to a player can also be directly edited using the following properties:
            </p>

<pre class="code"><code>character.statistics.skillPoints
character.statistics.availablePerks</code></pre>

            <div class="end-chapter"></div>

            <h4 class="card-title" id="c8-3">8.3 Scripting traits</h4>
            
            <p class="card-text">
              Traits scripts are located in <span class="mono-span">scripts/cmap/traits</span>. To add a new custom trait, let's create a new file in there:
            </p>

<div class="code-header">scripts/cmap/traits/fast-learner.mjs</div>
<pre class="code"><code>export function onToggled(characterSheet, toggled) {
  if (toggled)
    characterSheet.strength -= 3;
  else
    characterSheet.strength += 3;
}

export function modifyBaseStatistics(characterSheet, name, value) {
  if (name == "skillRate")
    return value + 10;
  return value;
}

export function modifyBaseSkill(characterSheet, name, value) {
  return value + 25;
}</code></pre>

            <p class="card-text">
              In this script, we exported all the functions available to traits:
            </p>
            
            <ul>
              <li><span class="mono-span">onToggled</span> is called when the trait is added or removed</li>
              <li><span class="mono-span">modifyBaseStatistics</span> is called for each statistic value when the base values are being re-computed</li>
              <li><span class="mono-span">modifyBaseSkill</span> is called for each skill value when the base values are being re-computed</li>
            </ul>
            
            <p class="card-text card-hint">
              Base values are computed using SPECIAL points, traits and race. Base values get updated everytime SPECIAL, traits or race are modified.
            </p>

            <p class="card-text">
              In our <span class="mono-span">onToggled</span> function, we decrease the character's strength on activation, and increase it on deactivation.
            </p>
            
            <p class="card-text">
              Our <span class="mono-span">modifyBaseStatistics</span> function increase the character's skillRate by ten, and leave other statistics as is.
            </p>
            
            <p class="card-text">
              And our <span class="mono-span">modifyBaseSkill</span> function increases each of the character's skill by 25 points.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c8-4">8.4 Scripting perks</h4>
            
            <p class="card-text">
              Perk scripts are located in <span class="mono-span">scripts/cmap/perks</span>. We will now create a simple perk with the following code:
            </p>

<div class="code-header">scripts/cmap/races/too-cool-for-school.mjs</div>
<pre class="code"><code>export function onToggled(characterSheet, toggled) {
  const modifier = toggled ? 1 : -1;

  characterSheet.charisma += (1 * modifier);
  characterSheet.speech   += (10 * modifier);
}

export function isAvailableFor(characterSheet) {
  return characterSheet.level > 2;
}</code></pre>

            <p class="card-text">
              You already know the <span class="mono-span">onToggled</span> function, as it is the same as for Traits scripts. In this perk example, we use it to modify the character's charisma characteristic and speech skill.
            </p>
            
            <p class="card-text">
              The important part here is <span class="mono-span">isAvailableFor</span>. Perks can only be picked if certain conditions are met, and this function will be called everytime the perk picking screen appears to figure out if your perk will be part of the options available to the player. In this script, we ensured that the perk wouldn't be available until the player reaches level 3.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c8-5">8.5 Scripting races</h4>
            
            <p class="card-text">
              Races scripts are located in <span class="mono-span">scripts/cmap/races</span>. Let's create a new race script:
            </p>
            
<div class="code-header">scripts/cmap/races/ghoul.mjs</div>
<pre class="code"><code>export const isPlayable = false;

export const spriteSheet = "earthpony-green";

export function onToggled(characterSheet, toggled) {
  const modifier = toggled ? 1 : -1;

  characterSheet.endurance -= (1 * modifier);
  characterSheet.strength  -= (1 * modifier);
}
</code></pre>

            <p class="card-text">
              Let's go over the exported values from that script:
            </p>
            
            <ul>
              <li><span class="mono-span">isPlayable</span> defines whether the race can be selected by a player on character creation.</li>
              <li><span class="mono-span">spriteSheet</span> defines the <a href="#c5-2">sprite group</a> containing the character's animation.</li>
              <li><span class="mono-span">onToggled</span>, as with other CMAP scripts, allows you to make changes to the character sheet when a character race changes.</li>
            </ul>
            
            <p class="card-text">
              What if a same race should use several sprite groups ? Neverfear, you can also export <span class="mono-span">spriteSheet</span> as a function, such as:
            </p>
            
<pre class="code"><code>export function spriteSheet(characterSheet) {
  if (characterSheet.gender == "male")
    return "ghoul-male";
  return "ghoul-female";
}
</code></pre>
            
            <div class="end-chapter"></div>
          </div>
        </div>
        
        <h2 class="my-4" id="c9">
          9. Quests
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title" id="c9-1">9.1 Creating a quest</h4>
          
            <p class="card-text">
              Quests are basically a set of objective that the player can achieve or fail to achieve. Quest scripts are located in the <span class="mono-span">scripts/quests</span> folder. Let's create our own quest:
            </p>
            
<div class="code-header">scripts/quests/myQuest.mjs</div>
<pre class="code"><code>class MyQuest {
  constructor(model) {
    this.model = model;
  }
  
  initialize() {
    game.appendToConsole("You picked up a new quest !");
  }
  
  getObjectives() {
    return [
      {label: "Objectif lune", success: false},
      {label: "Failed objective", failed: true },
      {label: "Completed objective", success: true }
    ];
  }
}

export function create(model) {
  return new MyQuest(model);
}</code></pre>

            <p class="card-text">
              Quest scripts are similar to other game object scripts. We added the <span class="mono-span">getObjectives</span> method to return a list of objectives to be displayed to the user. Objectives have three possible state: pending, failure or success (presented in the same order in our method).
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c9-2">9.2 Managing player quests</h4>
            
            <p class="card-text">
              Now that we can create our own quests, we should know how to add these quests to the player's quest log. We will see how to add a quest, using the <span class="mono-span">initialize.mjs</span> script as an example:
            </p>

            <div class="code-header">scripts/initialize.mjs</div>
            <pre class="code javascript"><code>export function initialize() {
  game.quests.addQuest("myQuest"); // &lt;-- here we go
  game.onCityEntered("stable-cavern", "demo-begin");
  game.worldmap.setPosition(150, 250);
  game.transitionRequired("intro.mp4", 1);
}</code></pre>

            <p class="card-text">
              Here, we use the QuestManager, accessbile using <span class="mono-span">game.quests</span> to add our <i>myQuest</i> quest to the player's active quests. The quest manager can also be used to fetch a specific quest object, or iterate over all active quests, using respectively <span class="mono-span">game.quests.getQuest("myQuest")</span> and <span class="mono-span">game.quests.list</span>.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c9-3">9.3 Completing objectives</h4>
            
            <p class="card-text">
              Now, how would we go around completing our objectives ? Well, this is mainly left to the script to decide. First, we must implement the <span class="mono-span">completeObjective</span> method:
            </p>
            
            <div class="code-header">scripts/quests/myQuest.mjs</div>
            <pre class="code javascript"><code>class MyQuest {
  constructor(model) {
    this.model = model;
  }
  
  completeObjective(objectiveName) {
    this.model.setVariable(objectiveName, 1);
    this.model.completed = true;
  }
  
  getObjectives() {
    return [
      {label: "Objectif lune", success: this.model.getVariable("myObjective") == 1}
    ]
  }
  
  onCompleted() {
    game.player.statistics.addExperience(1000);
    game.appendToConsole("You gained 1000 experience points for completing MyQuest");
  }
}</code></pre>

            <p class="card-text">
              In our <span class="mono-span">completeObjective</span>, we persist the state of our objective using <span class="mono-span">setVariable</span> on the quest object. Since our quest only includes one objective, we also set the <span class="mono-span">completed</span> property to true on the quest object.
            </p>
            
            <p class="card-text">
              We also added the <span class="mono-span">onCompleted</span> method, which gets called whenever <span class="mono-span">this.model.completed</span> goes from false to true.
            </p>
            
            <p class="card-text">
              We know how to react to an objective getting completed. Now, here's how you can trigger an objective completion from scripts:
            </p>
            
            <pre class="code javascript"><code>game.quests.getQuest("myQuest").completeObjective("myObjective")</code></pre>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c9-4">9.4 Watchers</h4>
            
            <p class="card-text">
              We know how to complete a quest objective from another script. But sometimes, it's not most convenient way to monitor quest objectives. Quest scripts can also implement watchers, to be warned when some events happen in the game.
            </p>
            
            <h5 class="card-title" id="9-4-1">9.4.1 Item picking watcher</h5>
            
            <p class="card-text">This watcher gets triggered whenever the player picks an item up. Here's an example:</p>
            
<pre class="code javascript"><code>class MyQuest {
  ...
  
  onItemPicked(item) {
    if (item.itemType == "someQuestItem") {
      this.model.setVariable("itemPicked", 1);
      this.model.completed = true;
    }
  }
}</code></pre>

            <h5 class="card-title" id="9-4-2">9.4.2 Character killed watcher</h5>
            
            <p class="card-text">This watcher gets triggered whenver a character gets killed, including if the killer wasn't the player, or the character didn't die in combat. Here's an example:</p>

<pre class="code javascript"><code>class MyQuest {
  ...
  
  onCharacterKilled(victim, killed) {
    if (victim.race == "mutated-rat") {
      const killCount = (this.model.getVariable("ratKilled") || 0) + 1;
      
      this.model.getVariable("ratKilled", killCount);
      if (killCount > 10)
        this.model.completed = true;
    }
  }
}</code></pre>

            <div class="end-chapter"></div>
          </div>
        </div>
        
        <h2 class="my-4" id="c10">
          10. Buffs
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title" id="c10-1">10.1 Introduction</h4>
          
            <p class="card-text">
              Buffs are bonuses or maluses that can be added to a Character. Buffs themselves are game objects, and the scripts are located at <span class="mono-span">scripts/buffs</span>. They feature a TaskManager, allowing for functions methods to be called regularly, and eventually remove the buff once it has expired.
            </p>
            
            <p class="card-text">
              Buffs on a character are visible in the status panel in the character sheet view, below the Hit points display:
            </p>

            <p class="card-text">
              <img src="pictures/buff-view.png" />
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c10-2">10.2 Adding and removing buffs</h4>

            <p class="card-text">
              Adding a buff on a character is fairly easy. The name of a buff is defined by the name of it scripts. To add the buff defined in <span class="mono-span">scripts/buffs/bleeding.mjs</span>, we would do the following:
            </p>
            
<pre class="code"><code>characters.addBuff("bleeding");</code></pre>

            <p class="card-text">
              The bleeding buff is a tick-based buff, meaning that once it runs off of ticks, the buff will remove itself. But what if we wanted to remove it, for another reason ? We will first need to fetch the buff game object, before removing it:
            </p>
            
<pre class="code"><code>const buff = characters.getBuff("bleeding");

if (buff)
  buff.remove();</code></pre>

            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c10-3">10.3 Creating a buff</h4>
            
            <p class="card-text">
              Now that we know how to apply or remove buffs from a character, let's see how to create our own custom buffs. Let's make a blinded buff, reducing the character's perception:
            </p>
            
<div class="code-header">scripts/buffs/blinded.mjs</div>
<pre class="code"><code>class Blinded {
  constructor(model) {
    this.model = model;
  }
  
  initialize() {
    this.model.target.statistics.perception -= 5;
  }
  
  finalize() {
    this.model.target.statistics.perception += 5;
  }
}

export function create(model) {
  return new Blinded(model);
}</code></pre>

            <p class="card-text">
              As you can see, like other game objects, buffs have an <span class="mono-span">initialize</span> method, whcih gets executed when the buff is applied on the player. But buffs also have a <span class="mono-span">finalize</span> method, which gets called as the buff gets removed from the character.
            </p>
            
            <p class="card-text">
              Currently, our buff will remain on the character indefinitely, until another script manually removes it. If we want our buff to expire, we can leverage the TaskManager:
            </p>
            
<div class="code-header">scripts/buffs/blinded.mjs</div>
<pre class="code"><code>class Blinded {
  constructor(model) {
    this.model = model;
  }
  
  initialize() {
    this.model.target.statistics.perception -= 5;
    this.tasks.addTask("expire", 86400000, 1);
  }
  
  finalize() {
    this.model.target.statistics.perception += 5;
  }
  
  expire() {
    this.model.remove();
  }
}

export function create(model) {
  return new Blinded(model);
}</code></pre>

            <p class="card-text">
              We now schedule a call to our <span class="mono-span">expire</span> method, one day after the buff gets applied. Then, in the <span class="mono-span">expire</span> method, we call our game object's <span class="mono-span">remove</span> method, which will in turn call the <span class="mono-span">finalize</span> method and remove the buff from the character.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c10-4">10.4 Cumulating buffs</h4>
            
            <p class="card-text">
              There is one important fact to know about buffs: there cannot be several instance of a same buff on the same player at a given time. However, it is possible to cumulate buffs using a single buff game object. We will now see what happens when you add a buff to a character, when an instance of the same buff is already being applied on a character.
            </p>
            
            <p class="card-text">
              If you were to call <span class="mono-span">character.addBuff("blinded")</span> twice, it's <span class="mono-span">initialize</span> method will only be called once. However, if you provide a <span class="mono-span">repeat</span> method, it will get called instead. Let's see how this might be implemented:
            </p>
            
<div class="code-header">scripts/buffs/blinded.mjs</div>
<pre class="code"><code>  repeat() {
    this.tasks.removeTask("expire");
    this.tasks.addTask("expire", 86400000, 1);
  }</code></pre>

            <p class="card-text">
              In our <span class="mono-span">repeat</span> method, we first unschedule the call to our <span class="mono-span">expire</span> method, and re-schedule it to one day in the future. This means applying the buff two times on a character doesn't change anything, but ensure that the buff won't expire until one day after the last addition, rather than one day after the first addition.
            </p>
            
            <div class="end-chapter"></div>
          </div>
        </div>
      </div>

      <!-- Sidebar Widgets Column -->
      <div class="col-md-4">
      
      <style>
      .card-body.card-index a {
        display: block;
      }
      
      .card-body.card-index .chapter {
        padding-left: 10px;
        padding-bottom: 5px;
      }
      
      .card-body.card-index .section {
        padding-left: 20px;
      }
      </style>

        <!-- Index Widget -->
        <div class="card my-4">
          <h5 class="card-header">Index</h5>
          <div class="card-body card-index">
            <a href="#c1">1. Level design</a>
            <div class="chapter">
              <a href="#c1-1">1.1 Creating a new tilemap</a>
              <a href="#c1-2">1.2 Walls</a>
              <a href="#c1-3">1.3 Roofs</a>
              <a href="#c1-4">1.4 Zones</a>
              <a href="#c1-5">1.5 Light zones</a>
            </div>
            <a href="#c2">2. Scripting introduction</a>
            <div class="chapter">
              <a href="#c2-1">2.1 Folder structure</a>
              <a href="#c2-2">2.2 Initializing a new game</a>
              <a href="#c2-3">2.3 Customizing the Game script</a>
              <a href="#c2-4">2.4 Scheduling a task</a>
            </div>
            <a href="#c3">3. Creating an NPC</a>
            <div class="chapter">
              <a href="#c3-1">3.1 Creating a new character script</a>
              <a href="#c3-2">3.2 Creating a character sheet</a>
              <a href="#c3-3">3.3 Adding an NPC in a level</a>
              <a href="#c3-4">3.4 Interactions and Text bubbles</a>
              <a href="#c3-5">3.5 Statistics checks and Inspection</a>
              <a href="#c3-6">3.6 Movement and actions</a>
              <a href="#c3-7">3.7 Combat and Diplomacy</a>
              <a href="#c3-8">3.8 Data storage</a>
            </div>
            <a href="#c4">4. Dialogs</a>
            <div class="chapter">
              <a href="#c4-1">4.1 Creating a new dialog</a>
              <a href="#c4-2">4.2 Lines and answers</a>
              <a href="#c4-3">4.3 Binding a dialog on a NPC</a>
              <a href="#c4-4">4.4 Scripting dialogs</a>
              <a href="#c4-6">4.6 Setting the mood</a>
            </div>
            <a href="#c5">5. Game Objects</a>
            <div class="chapter">
              <a href="#c5-1">5.1 Introduction</a>
              <a href="#c5-2">5.2 Sprites and positionning</a>
              <a href="#c5-3">5.3 Control zones</a>
              <a href="#c5-4">5.4 Detectability</a>
            </div>
            <a href="#c6">6. Inventory, items and equipment</a>
            <div class="chapter">
              <a href="#c6-1">6.1 Introduction</a>
              <a href="#c6-2">6.2 Storage Objects</a>
              <a href="#c6-3">6.3 Creating usable items</a>
              <a href="#c6-4">6.4 Inventory</a>
              <a href="#c6-5">6.5 Equipment</a>
            </div>
            <a href="#c7">7. Weapons</a>
            <div class="chapter">
              <a href="#c7-1">7.1 Creating a weapon</a>
              <a href="#c7-2">7.2 Custom animations</a>
              <a href="#c7-3">7.3 Dodging and critical failures</a>
              <a href="#c7-4">7.4 Reloading weapons</a>
              <a href="#c7-5">7.5 Playing sounds</a>
            </div>
            <a href="#c8">8. Cutie Mark Acquisition Program</a>
            <div class="chapter">
              <a href="#c8-1">8.1 Introduction to CMAP</a>
              <a href="#c8-2">8.2 Experience and levels</a>
              <a href="#c8-3">8.3 Scripting traits</a>
              <a href="#c8-4">8.4 Scripting perks</a>
              <a href="#c8-5">8.5 Scripting races</a>
            </div>
            <a href="#c9">9. Quests</a>
            <div class="chapter">
              <a href="#c9-1">9.1 Creating a quest</a>
              <a href="#c9-2">9.2 Managing player quests</a>
              <a href="#c9-3">9.3 Completing objectives</a>
              <a href="#c9-4">9.4 Watchers</a>
            </div>
            <a href="#c10">10. Buffs</a>
            <div class="chapter">
              <a href="#c10-1">10.1 Introduction</a>
              <a href="#c10-2">10.2 Adding and removing buffs</a>
              <a href="#c10-3">10.3 Creating a buff</a>
              <a href="#c10-4">10.4 Cumulating buffs</a>
            </div>
          </div>
        </div>
      </div>

    </div>
    <!-- /.row -->

  </div>
  <!-- /.container -->

  <!-- Footer -->
  <footer class="py-5 bg-dark">
    <div class="container">
      <p class="m-0 text-center text-white">Copyleft &copy; FoE Engine</p>
    </div>
    <!-- /.container -->
  </footer>

</body>

</html>
